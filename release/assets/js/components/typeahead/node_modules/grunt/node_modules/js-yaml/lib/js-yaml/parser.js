function ParserError(){_errors.MarkedYAMLError.apply(this,arguments),this.name="ParserError"}function Parser(){this.currentEvent=null,this.yamlVersion=null,this.tagHandles={},this.states=[],this.marks=[],this.state=this.parseStreamStart.bind(this)}var $$=require("./common"),_errors=require("./errors"),_tokens=require("./tokens"),_events=require("./events");$$.inherits(ParserError,_errors.MarkedYAMLError);var DEFAULT_TAGS={"!":"!","!!":"tag:yaml.org,2002:"};Parser.prototype.dispose=function(){this.states=[],this.state=null},Parser.prototype.checkEvent=function(){var e;if(null===this.currentEvent&&this.state&&(this.currentEvent=this.state()),null!==this.currentEvent){if(0===arguments.length)return!0;for(e=0;arguments.length>e;e+=1)if($$.isInstanceOf(this.currentEvent,arguments[e]))return!0}return!1},Parser.prototype.peekEvent=function(){return null===this.currentEvent&&this.state&&(this.currentEvent=this.state()),this.currentEvent},Parser.prototype.getEvent=function(){var e;return null===this.currentEvent&&this.state&&(this.currentEvent=this.state()),e=this.currentEvent,this.currentEvent=null,e},Parser.prototype.parseStreamStart=function(){var e,t;return e=this.getToken(),t=new _events.StreamStartEvent(e.startMark,e.endMark,e.encoding),this.state=this.parseImplicitDocumentStart.bind(this),t},Parser.prototype.parseImplicitDocumentStart=function(){var e,t;return this.checkToken(_tokens.DirectiveToken,_tokens.DocumentStartToken,_tokens.StreamEndToken)?this.parseDocumentStart():(this.tagHandles=DEFAULT_TAGS,e=this.peekToken(),t=new _events.DocumentStartEvent(e.startMark,e.startMark,!1),this.states.push(this.parseDocumentEnd.bind(this)),this.state=this.parseBlockNode.bind(this),t)},Parser.prototype.parseDocumentStart=function(){for(var e,t,n,r,i,o;this.checkToken(_tokens.DocumentEndToken);)this.getToken();if(this.checkToken(_tokens.StreamEndToken)){if(e=this.getToken(),t=new _events.StreamEndEvent(e.startMark,e.endMark),this.states&&this.states.length)throw new _errors.YAMLError("States supposed to be empty");if(this.marks&&this.marks.length)throw new _errors.YAMLError("Marks supposed to be empty");return this.state=null,t}if(e=this.peekToken(),i=e.startMark,o=this.processDirectives(),n=o.shift(),r=o.shift(),!this.checkToken(_tokens.DocumentStartToken))throw new ParserError(null,null,"expected '<document start>', but found "+this.peekToken().constructor.id,this.peekToken().startMark);return e=this.getToken(),t=new _events.DocumentStartEvent(i,e.endMark,!0,n,r),this.states.push(this.parseDocumentEnd.bind(this)),this.state=this.parseDocumentContent.bind(this),t},Parser.prototype.parseDocumentEnd=function(){var e,t,n,r,i;return e=this.peekToken(),r=i=e.startMark,n=!1,this.checkToken(_tokens.DocumentEndToken)&&(e=this.getToken(),i=e.endMark,n=!0),t=new _events.DocumentEndEvent(r,i,n),this.state=this.parseDocumentStart.bind(this),t},Parser.prototype.parseDocumentContent=function(){var e;return this.checkToken(_tokens.DirectiveToken,_tokens.DocumentStartToken,_tokens.DocumentEndToken,_tokens.StreamEndToken)?(e=this.processEmptyScalar(this.peekToken().startMark),this.state=this.states.pop(),e):this.parseBlockNode()},Parser.prototype.processDirectives=function(){var e,t,n,r;for(this.yamlVersion=null,this.tagHandles={};this.checkToken(_tokens.DirectiveToken);)if(e=this.getToken(),"YAML"===e.name){if(null!==this.yamlVersion)throw new ParserError(null,null,"found duplicate YAML directive",e.startMark);if(1!==+e.value[0])throw new ParserError(null,null,"found incompatible YAML document (version 1.* is required)",e.startMark);this.yamlVersion=e.value}else if("TAG"===e.name){if(t=e.value[0],n=e.value[1],void 0!==this.tagHandles[t])throw new ParserError(null,null,"duplicate tag handle "+t,e.startMark);this.tagHandles[t]=n}return Object.getOwnPropertyNames(this.tagHandles).length?(r=[this.yamlVersion,{}],Object.getOwnPropertyNames(this.tagHandles).forEach(function(e){r[1][e]=this.tagHandles[e]}.bind(this))):r=[this.yamlVersion,null],Object.getOwnPropertyNames(DEFAULT_TAGS).forEach(function(e){void 0===this.tagHandles[e]&&(this.tagHandles[e]=DEFAULT_TAGS[e])}.bind(this)),r},Parser.prototype.parseBlockNode=function(){return this.parseNode(!0)},Parser.prototype.parseFlowNode=function(){return this.parseNode()},Parser.prototype.parseBlockNodeOrIndentlessSequence=function(){return this.parseNode(!0,!0)},Parser.prototype.parseNode=function(e,t){var n,r,i,o,a,s,u=null,c=null,l=null,f=null,p=null;if(e=e||!1,t=t||!1,this.checkToken(_tokens.AliasToken))n=this.getToken(),r=new _events.AliasEvent(n.value,n.startMark,n.endMark),this.state=this.states.pop();else{if(u=null,c=null,l=i=o=null,this.checkToken(_tokens.AnchorToken)?(n=this.getToken(),l=n.startMark,i=n.endMark,u=n.value,this.checkToken(_tokens.TagToken)&&(n=this.getToken(),o=n.startMark,i=n.endMark,c=n.value)):this.checkToken(_tokens.TagToken)&&(n=this.getToken(),l=o=n.startMark,i=n.endMark,c=n.value,this.checkToken(_tokens.AnchorToken)&&(n=this.getToken(),i=n.endMark,u=n.value)),null!==c)if(f=c[0],p=c[1],null===f)c=p;else{if(void 0===this.tagHandles[f])throw new ParserError("while parsing a node",l,"found undefined tag handle "+f,o);c=this.tagHandles[f]+p}if(null===l&&(l=i=this.peekToken().startMark),r=null,a=null===c||"!"===c,t&&this.checkToken(_tokens.BlockEntryToken))i=this.peekToken().endMark,r=new _events.SequenceStartEvent(u,c,a,l,i),this.state=this.parseIndentlessSequenceEntry.bind(this);else if(this.checkToken(_tokens.ScalarToken))n=this.getToken(),i=n.endMark,a=n.plain&&null===c||"!"===c?[!0,!1]:null===c?[!1,!0]:[!1,!1],r=new _events.ScalarEvent(u,c,a,n.value,l,i,n.style),this.state=this.states.pop();else if(this.checkToken(_tokens.FlowSequenceStartToken))i=this.peekToken().endMark,r=new _events.SequenceStartEvent(u,c,a,l,i,!0),this.state=this.parseFlowSequenceFirstEntry.bind(this);else if(this.checkToken(_tokens.FlowMappingStartToken))i=this.peekToken().endMark,r=new _events.MappingStartEvent(u,c,a,l,i,!0),this.state=this.parseFlowMappingFirstKey.bind(this);else if(e&&this.checkToken(_tokens.BlockSequenceStartToken))i=this.peekToken().startMark,r=new _events.SequenceStartEvent(u,c,a,l,i,!1),this.state=this.parseBlockSequenceFirstEntry.bind(this);else if(e&&this.checkToken(_tokens.BlockMappingStartToken))i=this.peekToken().startMark,r=new _events.MappingStartEvent(u,c,a,l,i,!1),this.state=this.parseBlockMappingFirstKey.bind(this);else{if(null===u&&null===c)throw s=e?"block":"flow",n=this.peekToken(),new ParserError("while parsing a "+s+" node",l,"expected the node content, but found "+n.constructor.id,n.startMark);r=new _events.ScalarEvent(u,c,[a,!1],"",l,i),this.state=this.states.pop()}}return r},Parser.prototype.parseBlockSequenceFirstEntry=function(){var e=this.getToken();return this.marks.push(e.startMark),this.parseBlockSequenceEntry()},Parser.prototype.parseBlockSequenceEntry=function(){var e,t;if(this.checkToken(_tokens.BlockEntryToken))return e=this.getToken(),this.checkToken(_tokens.BlockEntryToken,_tokens.BlockEndToken)?(this.state=this.parseBlockSequenceEntry.bind(this),this.processEmptyScalar(e.endMark)):(this.states.push(this.parseBlockSequenceEntry.bind(this)),this.parseBlockNode());if(!this.checkToken(_tokens.BlockEndToken))throw e=this.peekToken(),new ParserError("while parsing a block collection",this.marks[this.marks.length-1],"expected <block end>, but found "+e.constructor.id,e.startMark);return e=this.getToken(),t=new _events.SequenceEndEvent(e.startMark,e.endMark),this.state=this.states.pop(),this.marks.pop(),t},Parser.prototype.parseIndentlessSequenceEntry=function(){var e,t;return this.checkToken(_tokens.BlockEntryToken)?(e=this.getToken(),this.checkToken(_tokens.BlockEntryToken,_tokens.KeyToken,_tokens.ValueToken,_tokens.BlockEndToken)?(this.state=this.parseIndentlessSequenceEntry.bind(this),this.processEmptyScalar(e.endMark)):(this.states.push(this.parseIndentlessSequenceEntry.bind(this)),this.parseBlockNode())):(e=this.peekToken(),t=new _events.SequenceEndEvent(e.startMark,e.startMark),this.state=this.states.pop(),t)},Parser.prototype.parseBlockMappingFirstKey=function(){var e=this.getToken();return this.marks.push(e.startMark),this.parseBlockMappingKey()},Parser.prototype.parseBlockMappingKey=function(){var e,t;if(this.checkToken(_tokens.KeyToken))return e=this.getToken(),this.checkToken(_tokens.KeyToken,_tokens.ValueToken,_tokens.BlockEndToken)?(this.state=this.parseBlockMappingValue.bind(this),this.processEmptyScalar(e.endMark)):(this.states.push(this.parseBlockMappingValue.bind(this)),this.parseBlockNodeOrIndentlessSequence());if(!this.checkToken(_tokens.BlockEndToken))throw e=this.peekToken(),new ParserError("while parsing a block mapping",this.marks[this.marks.length-1],"expected <block end>, but found "+e.constructor.id,e.startMark);return e=this.getToken(),t=new _events.MappingEndEvent(e.startMark,e.endMark),this.state=this.states.pop(),this.marks.pop(),t},Parser.prototype.parseBlockMappingValue=function(){var e;return this.checkToken(_tokens.ValueToken)?(e=this.getToken(),this.checkToken(_tokens.KeyToken,_tokens.ValueToken,_tokens.BlockEndToken)?(this.state=this.parseBlockMappingKey.bind(this),this.processEmptyScalar(e.endMark)):(this.states.push(this.parseBlockMappingKey.bind(this)),this.parseBlockNodeOrIndentlessSequence())):(this.state=this.parseBlockMappingKey.bind(this),e=this.peekToken(),this.processEmptyScalar(e.startMark))},Parser.prototype.parseFlowSequenceFirstEntry=function(){var e=this.getToken();return this.marks.push(e.startMark),this.parseFlowSequenceEntry(!0)},Parser.prototype.parseFlowSequenceEntry=function(e){var t,n;if(e=e||!1,!this.checkToken(_tokens.FlowSequenceEndToken)){if(!e){if(!this.checkToken(_tokens.FlowEntryToken))throw t=this.peekToken(),new ParserError("while parsing a flow sequence",this.marks[this.marks.length-1],"expected ',' or ']', but got "+t.constructor.id,t.startMark);this.getToken()}if(this.checkToken(_tokens.KeyToken))return t=this.peekToken(),n=new _events.MappingStartEvent(null,null,!0,t.startMark,t.endMark,!0),this.state=this.parseFlowSequenceEntryMappingKey.bind(this),n;if(!this.checkToken(_tokens.FlowSequenceEndToken))return this.states.push(this.parseFlowSequenceEntry.bind(this)),this.parseFlowNode()}return t=this.getToken(),n=new _events.SequenceEndEvent(t.startMark,t.endMark),this.state=this.states.pop(),this.marks.pop(),n},Parser.prototype.parseFlowSequenceEntryMappingKey=function(){var e=this.getToken();return this.checkToken(_tokens.ValueToken,_tokens.FlowEntryToken,_tokens.FlowSequenceEndToken)?(this.state=this.parseFlowSequenceEntryMappingValue.bind(this),this.processEmptyScalar(e.endMark)):(this.states.push(this.parseFlowSequenceEntryMappingValue.bind(this)),this.parseFlowNode())},Parser.prototype.parseFlowSequenceEntryMappingValue=function(){var e;return this.checkToken(_tokens.ValueToken)?(e=this.getToken(),this.checkToken(_tokens.FlowEntryToken,_tokens.FlowSequenceEndToken)?(this.state=this.parseFlowSequenceEntryMappingEnd.bind(this),this.processEmptyScalar(e.endMark)):(this.states.push(this.parseFlowSequenceEntryMappingEnd.bind(this)),this.parseFlowNode())):(this.state=this.parseFlowSequenceEntryMappingEnd.bind(this),e=this.peekToken(),this.processEmptyScalar(e.startMark))},Parser.prototype.parseFlowSequenceEntryMappingEnd=function(){var e;return this.state=this.parseFlowSequenceEntry.bind(this),e=this.peekToken(),new _events.MappingEndEvent(e.startMark,e.startMark)},Parser.prototype.parseFlowMappingFirstKey=function(){var e=this.getToken();return this.marks.push(e.startMark),this.parseFlowMappingKey(!0)},Parser.prototype.parseFlowMappingKey=function(e){var t,n;if(e=e||!1,!this.checkToken(_tokens.FlowMappingEndToken)){if(!e){if(!this.checkToken(_tokens.FlowEntryToken))throw t=this.peekToken(),new ParserError("while parsing a flow mapping",this.marks[this.marks.length-1],"expected ',' or '}', but got "+t.constructor.id,t.startMark);this.getToken()}if(this.checkToken(_tokens.KeyToken))return t=this.getToken(),this.checkToken(_tokens.ValueToken,_tokens.FlowEntryToken,_tokens.FlowMappingEndToken)?(this.state=this.parseFlowMappingValue.bind(this),this.processEmptyScalar(t.endMark)):(this.states.push(this.parseFlowMappingValue.bind(this)),this.parseFlowNode());if(!this.checkToken(_tokens.FlowMappingEndToken))return this.states.push(this.parseFlowMappingEmptyValue.bind(this)),this.parseFlowNode()}return t=this.getToken(),n=new _events.MappingEndEvent(t.startMark,t.endMark),this.state=this.states.pop(),this.marks.pop(),n},Parser.prototype.parseFlowMappingValue=function(){var e;return this.checkToken(_tokens.ValueToken)?(e=this.getToken(),this.checkToken(_tokens.FlowEntryToken,_tokens.FlowMappingEndToken)?(this.state=this.parseFlowMappingKey.bind(this),this.processEmptyScalar(e.endMark)):(this.states.push(this.parseFlowMappingKey.bind(this)),this.parseFlowNode())):(this.state=this.parseFlowMappingKey.bind(this),e=this.peekToken(),this.processEmptyScalar(e.startMark))},Parser.prototype.parseFlowMappingEmptyValue=function(){return this.state=this.parseFlowMappingKey.bind(this),this.processEmptyScalar(this.peekToken().startMark)},Parser.prototype.processEmptyScalar=function(e){return new _events.ScalarEvent(null,null,[!0,!1],"",e,e)},module.exports.Parser=Parser;
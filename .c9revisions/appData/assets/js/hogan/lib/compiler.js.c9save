{"ts":1361944703894,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"/*\r\n *  Copyright 2011 Twitter, Inc.\r\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n *  you may not use this file except in compliance with the License.\r\n *  You may obtain a copy of the License at\r\n *\r\n *  http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n *  Unless required by applicable law or agreed to in writing, software\r\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n *  See the License for the specific language governing permissions and\r\n *  limitations under the License.\r\n */\r\n\r\n(function (Hogan) {\r\n  // Setup regex  assignments\r\n  // remove whitespace according to Mustache spec\r\n  var rIsWhitespace = /\\S/,\r\n      rQuot = /\\\"/g,\r\n      rNewline =  /\\n/g,\r\n      rCr = /\\r/g,\r\n      rSlash = /\\\\/g,\r\n      tagTypes = {\r\n        '#': 1, '^': 2, '/': 3,  '!': 4, '>': 5,\r\n        '<': 6, '=': 7, '_v': 8, '{': 9, '&': 10\r\n      };\r\n\r\n  Hogan.scan = function scan(text, delimiters) {\r\n    var len = text.length,\r\n        IN_TEXT = 0,\r\n        IN_TAG_TYPE = 1,\r\n        IN_TAG = 2,\r\n        state = IN_TEXT,\r\n        tagType = null,\r\n        tag = null,\r\n        buf = '',\r\n        tokens = [],\r\n        seenTag = false,\r\n        i = 0,\r\n        lineStart = 0,\r\n        otag = '{{',\r\n        ctag = '}}';\r\n\r\n    function addBuf() {\r\n      if (buf.length > 0) {\r\n        tokens.push(new String(buf));\r\n        buf = '';\r\n      }\r\n    }\r\n\r\n    function lineIsWhitespace() {\r\n      var isAllWhitespace = true;\r\n      for (var j = lineStart; j < tokens.length; j++) {\r\n        isAllWhitespace =\r\n          (tokens[j].tag && tagTypes[tokens[j].tag] < tagTypes['_v']) ||\r\n          (!tokens[j].tag && tokens[j].match(rIsWhitespace) === null);\r\n        if (!isAllWhitespace) {\r\n          return false;\r\n        }\r\n      }\r\n\r\n      return isAllWhitespace;\r\n    }\r\n\r\n    function filterLine(haveSeenTag, noNewLine) {\r\n      addBuf();\r\n\r\n      if (haveSeenTag && lineIsWhitespace()) {\r\n        for (var j = lineStart, next; j < tokens.length; j++) {\r\n          if (!tokens[j].tag) {\r\n            if ((next = tokens[j+1]) && next.tag == '>') {\r\n              // set indent to token value\r\n              next.indent = tokens[j].toString()\r\n            }\r\n            tokens.splice(j, 1);\r\n          }\r\n        }\r\n      } else if (!noNewLine) {\r\n        tokens.push({tag:'\\n'});\r\n      }\r\n\r\n      seenTag = false;\r\n      lineStart = tokens.length;\r\n    }\r\n\r\n    function changeDelimiters(text, index) {\r\n      var close = '=' + ctag,\r\n          closeIndex = text.indexOf(close, index),\r\n          delimiters = trim(\r\n            text.substring(text.indexOf('=', index) + 1, closeIndex)\r\n          ).split(' ');\r\n\r\n      otag = delimiters[0];\r\n      ctag = delimiters[1];\r\n\r\n      return closeIndex + close.length - 1;\r\n    }\r\n\r\n    if (delimiters) {\r\n      delimiters = delimiters.split(' ');\r\n      otag = delimiters[0];\r\n      ctag = delimiters[1];\r\n    }\r\n\r\n    for (i = 0; i < len; i++) {\r\n      if (state == IN_TEXT) {\r\n        if (tagChange(otag, text, i)) {\r\n          --i;\r\n          addBuf();\r\n          state = IN_TAG_TYPE;\r\n        } else {\r\n          if (text.charAt(i) == '\\n') {\r\n            filterLine(seenTag);\r\n          } else {\r\n            buf += text.charAt(i);\r\n          }\r\n        }\r\n      } else if (state == IN_TAG_TYPE) {\r\n        i += otag.length - 1;\r\n        tag = tagTypes[text.charAt(i + 1)];\r\n        tagType = tag ? text.charAt(i + 1) : '_v';\r\n        if (tagType == '=') {\r\n          i = changeDelimiters(text, i);\r\n          state = IN_TEXT;\r\n        } else {\r\n          if (tag) {\r\n            i++;\r\n          }\r\n          state = IN_TAG;\r\n        }\r\n        seenTag = i;\r\n      } else {\r\n        if (tagChange(ctag, text, i)) {\r\n          tokens.push({tag: tagType, n: trim(buf), otag: otag, ctag: ctag,\r\n                       i: (tagType == '/') ? seenTag - ctag.length : i + otag.length});\r\n          buf = '';\r\n          i += ctag.length - 1;\r\n          state = IN_TEXT;\r\n          if (tagType == '{') {\r\n            if (ctag == '}}') {\r\n              i++;\r\n            } else {\r\n              cleanTripleStache(tokens[tokens.length - 1]);\r\n            }\r\n          }\r\n        } else {\r\n          buf += text.charAt(i);\r\n        }\r\n      }\r\n    }\r\n\r\n    filterLine(seenTag, true);\r\n\r\n    return tokens;\r\n  }\r\n\r\n  function cleanTripleStache(token) {\r\n    if (token.n.substr(token.n.length - 1) === '}') {\r\n      token.n = token.n.substring(0, token.n.length - 1);\r\n    }\r\n  }\r\n\r\n  function trim(s) {\r\n    if (s.trim) {\r\n      return s.trim();\r\n    }\r\n\r\n    return s.replace(/^\\s*|\\s*$/g, '');\r\n  }\r\n\r\n  function tagChange(tag, text, index) {\r\n    if (text.charAt(index) != tag.charAt(0)) {\r\n      return false;\r\n    }\r\n\r\n    for (var i = 1, l = tag.length; i < l; i++) {\r\n      if (text.charAt(index + i) != tag.charAt(i)) {\r\n        return false;\r\n      }\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  function buildTree(tokens, kind, stack, customTags) {\r\n    var instructions = [],\r\n        opener = null,\r\n        token = null;\r\n\r\n    while (tokens.length > 0) {\r\n      token = tokens.shift();\r\n      if (token.tag == '#' || token.tag == '^' || isOpener(token, customTags)) {\r\n        stack.push(token);\r\n        token.nodes = buildTree(tokens, token.tag, stack, customTags);\r\n        instructions.push(token);\r\n      } else if (token.tag == '/') {\r\n        if (stack.length === 0) {\r\n          throw new Error('Closing tag without opener: /' + token.n);\r\n        }\r\n        opener = stack.pop();\r\n        if (token.n != opener.n && !isCloser(token.n, opener.n, customTags)) {\r\n          throw new Error('Nesting error: ' + opener.n + ' vs. ' + token.n);\r\n        }\r\n        opener.end = token.i;\r\n        return instructions;\r\n      } else {\r\n        instructions.push(token);\r\n      }\r\n    }\r\n\r\n    if (stack.length > 0) {\r\n      throw new Error('missing closing tag: ' + stack.pop().n);\r\n    }\r\n\r\n    return instructions;\r\n  }\r\n\r\n  function isOpener(token, tags) {\r\n    for (var i = 0, l = tags.length; i < l; i++) {\r\n      if (tags[i].o == token.n) {\r\n        token.tag = '#';\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  function isCloser(close, open, tags) {\r\n    for (var i = 0, l = tags.length; i < l; i++) {\r\n      if (tags[i].c == close && tags[i].o == open) {\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n\r\n  function writeCode(tree) {\r\n    return 'var _=this;_.b(i=i||\"\");' + walk(tree) + 'return _.fl();';\r\n  }\r\n\r\n  Hogan.generate = function (code, text, options) {\r\n    if (options.asString) {\r\n      return 'function(c,p,i){' + code + ';}';\r\n    }\r\n\r\n    return new Hogan.Template(new Function('c', 'p', 'i', code), text, Hogan, options);\r\n  }\r\n\r\n  function esc(s) {\r\n    return s.replace(rSlash, '\\\\\\\\')\r\n            .replace(rQuot, '\\\\\\\"')\r\n            .replace(rNewline, '\\\\n')\r\n            .replace(rCr, '\\\\r');\r\n  }\r\n\r\n  function chooseMethod(s) {\r\n    return (~s.indexOf('.')) ? 'd' : 'f';\r\n  }\r\n\r\n  function walk(tree) {\r\n    var code = '';\r\n    for (var i = 0, l = tree.length; i < l; i++) {\r\n      var tag = tree[i].tag;\r\n      if (tag == '#') {\r\n        code += section(tree[i].nodes, tree[i].n, chooseMethod(tree[i].n),\r\n                        tree[i].i, tree[i].end, tree[i].otag + \" \" + tree[i].ctag);\r\n      } else if (tag == '^') {\r\n        code += invertedSection(tree[i].nodes, tree[i].n,\r\n                                chooseMethod(tree[i].n));\r\n      } else if (tag == '<' || tag == '>') {\r\n        code += partial(tree[i]);\r\n      } else if (tag == '{' || tag == '&') {\r\n        code += tripleStache(tree[i].n, chooseMethod(tree[i].n));\r\n      } else if (tag == '\\n') {\r\n        code += text('\"\\\\n\"' + (tree.length-1 == i ? '' : ' + i'));\r\n      } else if (tag == '_v') {\r\n        code += variable(tree[i].n, chooseMethod(tree[i].n));\r\n      } else if (tag === undefined) {\r\n        code += text('\"' + esc(tree[i]) + '\"');\r\n      }\r\n    }\r\n    return code;\r\n  }\r\n\r\n  function section(nodes, id, method, start, end, tags) {\r\n    return 'if(_.s(_.' + method + '(\"' + esc(id) + '\",c,p,1),' +\r\n           'c,p,0,' + start + ',' + end + ',\"' + tags + '\")){' +\r\n           '_.rs(c,p,' +\r\n           'function(c,p,_){' +\r\n           walk(nodes) +\r\n           '});c.pop();}';\r\n  }\r\n\r\n  function invertedSection(nodes, id, method) {\r\n    return 'if(!_.s(_.' + method + '(\"' + esc(id) + '\",c,p,1),c,p,1,0,0,\"\")){' +\r\n           walk(nodes) +\r\n           '};';\r\n  }\r\n\r\n  function partial(tok) {\r\n    return '_.b(_.rp(\"' +  esc(tok.n) + '\",c,p,\"' + (tok.indent || '') + '\"));';\r\n  }\r\n\r\n  function tripleStache(id, method) {\r\n    return '_.b(_.t(_.' + method + '(\"' + esc(id) + '\",c,p,0)));';\r\n  }\r\n\r\n  function variable(id, method) {\r\n    return '_.b(_.v(_.' + method + '(\"' + esc(id) + '\",c,p,0)));';\r\n  }\r\n\r\n  function text(id) {\r\n    return '_.b(' + id + ');';\r\n  }\r\n\r\n  Hogan.parse = function(tokens, text, options) {\r\n    options = options || {};\r\n    return buildTree(tokens, '', [], options.sectionTags || []);\r\n  },\r\n\r\n  Hogan.cache = {};\r\n\r\n  Hogan.compile = function(text, options) {\r\n    // options\r\n    //\r\n    // asString: false (default)\r\n    //\r\n    // sectionTags: [{o: '_foo', c: 'foo'}]\r\n    // An array of object with o and c fields that indicate names for custom\r\n    // section tags. The example above allows parsing of {{_foo}}{{/foo}}.\r\n    //\r\n    // delimiters: A string that overrides the default delimiters.\r\n    // Example: \"<% %>\"\r\n    //\r\n    options = options || {};\r\n\r\n    var key = text + '||' + !!options.asString;\r\n\r\n    var t = Hogan.cache[key];\r\n\r\n    if (t) {\r\n      return t;\r\n    }\r\n\r\n    t = Hogan.generate(writeCode(Hogan.parse(Hogan.scan(text, options.delimiters), text, options)), text, options);\r\n    return Hogan.cache[key] = t;\r\n  };\r\n})(typeof exports !== 'undefined' ? exports : Hogan);"]],"start1":0,"start2":0,"length1":0,"length2":9821}]],"length":9821}

{"ts":1361600415529,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"// ==========================================\n// Copyright 2013 Twitter, Inc\n// Licensed under The MIT License\n// http://opensource.org/licenses/MIT\n// ==========================================\n\n\"use strict\";\n\ndefine(\n\n  [\n    './advice',\n    './utils',\n    './compose',\n    './registry'\n  ],\n\n  function(advice, utils, compose, registry) {\n\n    var functionNameRegEx = /function (.*?)\\s?\\(/;\n    var spaceCommaRegEx = /\\s\\,/g;\n\n    function teardownInstance(instanceInfo){\n      instanceInfo.events.slice().forEach(function(event) {\n        var args = [event.type];\n\n        event.element && args.unshift(event.element);\n        (typeof event.callback == 'function') && args.push(event.callback);\n\n        this.off.apply(this, args);\n      }, instanceInfo.instance);\n    }\n\n\n    function teardown() {\n      this.trigger(\"componentTearDown\");\n      teardownInstance(registry.findInstanceInfo(this));\n    }\n\n    //teardown for all instances of this constructor\n    function teardownAll() {\n      var componentInfo = registry.findComponentInfo(this);\n\n      componentInfo && componentInfo.instances.slice().forEach(function(info) {\n        info.instance.teardown();\n      });\n    }\n\n    function checkSerializable(type, data) {\n      try {\n        window.postMessage(data, '*');\n      } catch(e) {\n        console.log('unserializable data for event',type,':',data);\n        throw new Error(\n          [\"The event\", type, \"on component\", this.describe, \"was triggered with non-serializable data\"].join(\" \")\n        );\n      }\n    }\n\n    //common mixin allocates basic functionality - used by all component prototypes\n    //callback context is bound to component\n    function withBaseComponent() {\n\n      // delegate trigger, bind and unbind to an element\n      // if $element not supplied, use component's node\n      // other arguments are passed on\n      // event can be either a string specifying the type\n      // of the event, or a hash specifying both the type\n      // and a default function to be called.\n      this.trigger = function() {\n        var $element, type, data, event, defaultFn;\n        var args = utils.toArray(arguments);\n        var lastArg = args[args.length - 1];\n\n        if (typeof lastArg != \"string\" && !(lastArg && lastArg.defaultBehavior)) {\n          data = args.pop();\n        }\n\n        $element = (args.length == 2) ? $(args.shift()) : this.$node;\n        event = args[0];\n\n        if (event.defaultBehavior) {\n          defaultFn = event.defaultBehavior;\n          event = $.Event(event.type);\n        }\n\n        type = event.type || event;\n\n        if (window.DEBUG && window.postMessage) {\n          checkSerializable.call(this, type, data);\n        }\n\n        if (typeof this.attr.eventData === 'object') {\n          data = $.extend(true, {}, this.attr.eventData, data);\n        }\n\n        var returnVal = $element.trigger((event || type), data);\n\n        if (defaultFn && !event.isDefaultPrevented()) {\n          (this[defaultFn] || defaultFn).call(this);\n        }\n\n        return returnVal;\n      };\n\n      this.on = function() {\n        var $element, type, callback, originalCb;\n        var args = utils.toArray(arguments);\n\n        if (typeof args[args.length - 1] == \"object\") {\n          //delegate callback\n          originalCb = utils.delegate(\n            this.resolveDelegateRules(args.pop())\n          );\n        } else {\n          originalCb = args.pop();\n        }\n\n        $element = (args.length == 2) ? $(args.shift()) : this.$node;\n        type = args[0];\n\n        if (typeof originalCb != 'function' && typeof originalCb != 'object') {\n          throw new Error(\"Unable to bind to '\" + type + \"' because the given callback is not a function or an object\");\n        }\n\n        callback = originalCb.bind(this);\n        callback.target = originalCb;\n\n        // if the original callback is already branded by jQuery's guid, copy it to the context-bound version\n        if (originalCb.guid) {\n          callback.guid = originalCb.guid;\n        }\n\n        $element.on(type, callback);\n\n        // get jquery's guid from our bound fn, so unbinding will work\n        originalCb.guid = callback.guid;\n\n        return callback;\n      };\n\n      this.off = function() {\n        var $element, type, callback;\n        var args = utils.toArray(arguments);\n\n        if (typeof args[args.length - 1] == \"function\") {\n          callback = args.pop();\n        }\n\n        $element = (args.length == 2) ? $(args.shift()) : this.$node;\n        type = args[0];\n\n        return $element.off(type, callback);\n      };\n\n      this.resolveDelegateRules = function(ruleInfo) {\n        var rules = {};\n\n        Object.keys(ruleInfo).forEach(\n          function(r) {\n            if (!this.attr.hasOwnProperty(r)) {\n              throw new Error('Component \"' + this.describe + '\" wants to listen on \"' + r + '\" but no such attribute was defined.');\n            }\n            rules[this.attr[r]] = ruleInfo[r];\n          },\n          this\n        );\n\n        return rules;\n      };\n\n      this.defaultAttrs = function(defaults) {\n        utils.push(this.defaults, defaults, true) || (this.defaults = defaults);\n      };\n\n      this.select = function(attributeKey) {\n        return this.$node.find(this.attr[attributeKey]);\n      };\n\n      this.initialize = $.noop;\n      this.teardown = teardown;\n    }\n\n    function attachTo(selector/*, options args */) {\n      if (!selector) {\n        throw new Error(\"Component needs to be attachTo'd a jQuery object, native node or selector string\");\n      }\n\n      var options = utils.merge.apply(utils, utils.toArray(arguments, 1));\n\n      $(selector).each(function(i, node) {\n        new this(node, options);\n      }.bind(this));\n    }\n\n    // define the constructor for a custom component type\n    // takes an unlimited number of mixin functions as arguments\n    // typical api call with 3 mixins: define(timeline, withTweetCapability, withScrollCapability);\n    function define(/*mixins*/) {\n      var mixins = utils.toArray(arguments);\n\n      Component.toString = function() {\n        var prettyPrintMixins = mixins.map(function(mixin) {\n          if ($.browser.msie) {\n            var m = mixin.toString().match(functionNameRegEx);\n            return (m && m[1]) ? m[1] : \"\";\n          } else {\n            return mixin.name;\n          }\n        }).join(', ').replace(spaceCommaRegEx,'');//weed out no-named mixins\n\n        return prettyPrintMixins;\n      };\n\n      Component.describe = Component.toString();\n\n      //'options' is optional hash to be merged with 'defaults' in the component definition\n      function Component(node, options) {\n        var fnCache = {}, uuid = 0;\n\n        if (!node) {\n          throw new Error(\"Component needs a node\");\n        }\n\n        if (node.jquery) {\n          this.node = node[0];\n          this.$node = node;\n        } else {\n          this.node = node;\n          this.$node = $(node);\n        }\n\n        this.describe = this.constructor.describe;\n\n        this.bind = function(func) {\n          var bound;\n\n          if (func.uuid && (bound = fnCache[func.uuid])) {\n            return bound;\n          }\n\n          var bindArgs = utils.toArray(arguments, 1);\n          bindArgs.unshift(this); //prepend context\n\n          bound = func.bind.apply(func, bindArgs);\n          bound.target = func;\n          func.uuid = uuid++;\n          fnCache[func.uuid] = bound;\n\n          return bound;\n        };\n\n        //merge defaults with supplied options\n        this.attr = utils.merge(this.defaults, options);\n        this.defaults && Object.keys(this.defaults).forEach(function(key) {\n          if (this.defaults[key] === null && this.attr[key] === null) {\n            throw new Error('Required attribute \"' + key + '\" not specified in attachTo for component \"' + this.describe + '\".');\n          }\n        }, this);\n\n        this.initialize.call(this, options || {});\n\n        this.trigger('componentInitialized');\n      }\n\n      Component.attachTo = attachTo;\n      Component.teardownAll = teardownAll;\n\n      // prepend common mixins to supplied list, then mixin all flavors\n      mixins.unshift(withBaseComponent, advice.withAdvice, registry.withRegistration);\n\n      compose.mixin(Component.prototype, mixins);\n\n      return Component;\n    }\n\n    define.teardownAll = function() {\n      registry.components.slice().forEach(function(c) {\n        c.component.teardownAll();\n      });\n      registry.reset();\n    };\n\n    return define;\n  }\n);\n"]],"start1":0,"start2":0,"length1":0,"length2":8455}]],"length":8455}

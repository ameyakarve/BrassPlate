{"ts":1361605344477,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"define([], function() {\r\n\r\n\r\n    //\r\n    // Generated on Sun Dec 16 2012 22:47:05 GMT-0500 (EST) by Nodejitsu, Inc (Using Codesurgeon).\r\n    // Version 1.1.9\r\n    //\r\n\r\n    \r\n\r\n\r\n        /*\r\n         * browser.js: Browser specific functionality for director.\r\n         *\r\n         * (C) 2011, Nodejitsu Inc.\r\n         * MIT LICENSE\r\n         *\r\n         */\r\n\r\n        if (!Array.prototype.filter) {\r\n            Array.prototype.filter = function(filter, that) {\r\n                var other = [],\r\n                    v;\r\n                for (var i = 0, n = this.length; i < n; i++) {\r\n                    if (i in this && filter.call(that, v = this[i], i, this)) {\r\n                        other.push(v);\r\n                    }\r\n                }\r\n                return other;\r\n            };\r\n        }\r\n\r\n        if (!Array.isArray) {\r\n            Array.isArray = function(obj) {\r\n                return Object.prototype.toString.call(obj) === '[object Array]';\r\n            };\r\n        }\r\n\r\n        var dloc = document.location;\r\n\r\n        function dlocHashEmpty() {\r\n            // Non-IE browsers return '' when the address bar shows '#'; Director's logic\r\n            // assumes both mean empty.\r\n            return dloc.hash === '' || dloc.hash === '#';\r\n        }\r\n\r\n        var listener = {\r\n            mode: 'modern',\r\n            hash: dloc.hash,\r\n            history: false,\r\n\r\n            check: function() {\r\n                var h = dloc.hash;\r\n                if (h != this.hash) {\r\n                    this.hash = h;\r\n                    this.onHashChanged();\r\n                }\r\n            },\r\n\r\n            fire: function() {\r\n                if (this.mode === 'modern') {\r\n                    this.history === true ? window.onpopstate() : window.onhashchange();\r\n                }\r\n                else {\r\n                    this.onHashChanged();\r\n                }\r\n            },\r\n\r\n            init: function(fn, history) {\r\n                var self = this;\r\n                this.history = history;\r\n\r\n                if (!Router.listeners) {\r\n                    Router.listeners = [];\r\n                }\r\n\r\n                function onchange(onChangeEvent) {\r\n                    for (var i = 0, l = Router.listeners.length; i < l; i++) {\r\n                        Router.listeners[i](onChangeEvent);\r\n                    }\r\n                }\r\n\r\n                //note IE8 is being counted as 'modern' because it has the hashchange event\r\n                if ('onhashchange' in window && (document.documentMode === undefined || document.documentMode > 7)) {\r\n                    // At least for now HTML5 history is available for 'modern' browsers only\r\n                    if (this.history === true) {\r\n                        // There is an old bug in Chrome that causes onpopstate to fire even\r\n                        // upon initial page load. Since the handler is run manually in init(),\r\n                        // this would cause Chrome to run it twise. Currently the only\r\n                        // workaround seems to be to set the handler after the initial page load\r\n                        // http://code.google.com/p/chromium/issues/detail?id=63040\r\n                        setTimeout(function() {\r\n                            window.onpopstate = onchange;\r\n                        }, 500);\r\n                    }\r\n                    else {\r\n                        window.onhashchange = onchange;\r\n                    }\r\n                    this.mode = 'modern';\r\n                }\r\n                else {\r\n                    //\r\n                    // IE support, based on a concept by Erik Arvidson ...\r\n                    //\r\n                    var frame = document.createElement('iframe');\r\n                    frame.id = 'state-frame';\r\n                    frame.style.display = 'none';\r\n                    document.body.appendChild(frame);\r\n                    this.writeFrame('');\r\n\r\n                    if ('onpropertychange' in document && 'attachEvent' in document) {\r\n                        document.attachEvent('onpropertychange', function() {\r\n                            if (event.propertyName === 'location') {\r\n                                self.check();\r\n                            }\r\n                        });\r\n                    }\r\n\r\n                    window.setInterval(function() {\r\n                        self.check();\r\n                    }, 50);\r\n\r\n                    this.onHashChanged = onchange;\r\n                    this.mode = 'legacy';\r\n                }\r\n\r\n                Router.listeners.push(fn);\r\n\r\n                return this.mode;\r\n            },\r\n\r\n            destroy: function(fn) {\r\n                if (!Router || !Router.listeners) {\r\n                    return;\r\n                }\r\n\r\n                var listeners = Router.listeners;\r\n\r\n                for (var i = listeners.length - 1; i >= 0; i--) {\r\n                    if (listeners[i] === fn) {\r\n                        listeners.splice(i, 1);\r\n                    }\r\n                }\r\n            },\r\n\r\n            setHash: function(s) {\r\n                // Mozilla always adds an entry to the history\r\n                if (this.mode === 'legacy') {\r\n                    this.writeFrame(s);\r\n                }\r\n\r\n                if (this.history === true) {\r\n                    window.history.pushState({}, document.title, s);\r\n                    // Fire an onpopstate event manually since pushing does not obviously\r\n                    // trigger the pop event.\r\n                    this.fire();\r\n                }\r\n                else {\r\n                    dloc.hash = (s[0] === '/') ? s : '/' + s;\r\n                }\r\n                return this;\r\n            },\r\n\r\n            writeFrame: function(s) {\r\n                // IE support...\r\n                var f = document.getElementById('state-frame');\r\n                var d = f.contentDocument || f.contentWindow.document;\r\n                d.open();\r\n                d.write(\"<script>_hash = '\" + s + \"'; onload = parent.listener.syncHash;<script>\");\r\n                d.close();\r\n            },\r\n\r\n            syncHash: function() {\r\n                // IE support...\r\n                var s = this._hash;\r\n                if (s != dloc.hash) {\r\n                    dloc.hash = s;\r\n                }\r\n                return this;\r\n            },\r\n\r\n            onHashChanged: function() {}\r\n        };\r\n\r\n        var Router = Router = function(routes) {\r\n            if (!(this instanceof Router)) return new Router(routes);\r\n\r\n            this.params = {};\r\n            this.routes = {};\r\n            this.methods = ['on', 'once', 'after', 'before'];\r\n            this.scope = [];\r\n            this._methods = {};\r\n\r\n            this._insert = this.insert;\r\n            this.insert = this.insertEx;\r\n\r\n            this.historySupport = (window.history != null ? window.history.pushState : null) != null\r\n\r\n            this.configure();\r\n            this.mount(routes || {});\r\n        };\r\n\r\n        Router.prototype.init = function(r) {\r\n            var self = this;\r\n            this.handler = function(onChangeEvent) {\r\n                var newURL = onChangeEvent && onChangeEvent.newURL || window.location.hash;\r\n                var url = self.history === true ? self.getPath() : newURL.replace(/.*#/, '');\r\n                self.dispatch('on', url);\r\n            };\r\n\r\n            listener.init(this.handler, this.history);\r\n\r\n            if (this.history === false) {\r\n                if (dlocHashEmpty() && r) {\r\n                    dloc.hash = r;\r\n                }\r\n                else if (!dlocHashEmpty()) {\r\n                    self.dispatch('on', dloc.hash.replace(/^#/, ''));\r\n                }\r\n            }\r\n            else {\r\n                var routeTo = dlocHashEmpty() && r ? r : !dlocHashEmpty() ? dloc.hash.replace(/^#/, '') : null;\r\n                if (routeTo) {\r\n                    window.history.replaceState({}, document.title, routeTo);\r\n                }\r\n\r\n                // Router has been initialized, but due to the chrome bug it will not\r\n                // yet actually route HTML5 history state changes. Thus, decide if should route.\r\n                if (routeTo || this.run_in_init === true) {\r\n                    this.handler();\r\n                }\r\n            }\r\n\r\n            return this;\r\n        };\r\n\r\n        Router.prototype.explode = function() {\r\n            var v = this.history === true ? this.getPath() : dloc.hash;\r\n            if (v.charAt(1) === '/') {\r\n                v = v.slice(1)\r\n            }\r\n            return v.slice(1, v.length).split(\"/\");\r\n        };\r\n\r\n        Router.prototype.setRoute = function(i, v, val) {\r\n            var url = this.explode();\r\n\r\n            if (typeof i === 'number' && typeof v === 'string') {\r\n                url[i] = v;\r\n            }\r\n            else if (typeof val === 'string') {\r\n                url.splice(i, v, s);\r\n            }\r\n            else {\r\n                url = [i];\r\n            }\r\n\r\n            listener.setHash(url.join('/'));\r\n            return url;\r\n        };\r\n\r\n        //\r\n        // ### function insertEx(method, path, route, parent)\r\n        // #### @method {string} Method to insert the specific `route`.\r\n        // #### @path {Array} Parsed path to insert the `route` at.\r\n        // #### @route {Array|function} Route handlers to insert.\r\n        // #### @parent {Object} **Optional** Parent \"routes\" to insert into.\r\n        // insert a callback that will only occur once per the matched route.\r\n        //\r\n        Router.prototype.insertEx = function(method, path, route, parent) {\r\n            if (method === \"once\") {\r\n                method = \"on\";\r\n                route = function(route) {\r\n                    var once = false;\r\n                    return function() {\r\n                        if (once) return;\r\n                        once = true;\r\n                        return route.apply(this, arguments);\r\n                    };\r\n                }(route);\r\n            }\r\n            return this._insert(method, path, route, parent);\r\n        };\r\n\r\n        Router.prototype.getRoute = function(v) {\r\n            var ret = v;\r\n\r\n            if (typeof v === \"number\") {\r\n                ret = this.explode()[v];\r\n            }\r\n            else if (typeof v === \"string\") {\r\n                var h = this.explode();\r\n                ret = h.indexOf(v);\r\n            }\r\n            else {\r\n                ret = this.explode();\r\n            }\r\n\r\n            return ret;\r\n        };\r\n\r\n        Router.prototype.destroy = function() {\r\n            listener.destroy(this.handler);\r\n            return this;\r\n        };\r\n\r\n        Router.prototype.getPath = function() {\r\n            var path = window.location.pathname;\r\n            if (path.substr(0, 1) !== '/') {\r\n                path = '/' + path;\r\n            }\r\n            return path;\r\n        };\r\n\r\n        function _every(arr, iterator) {\r\n            for (var i = 0; i < arr.length; i += 1) {\r\n                if (iterator(arr[i], i, arr) === false) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n\r\n        function _flatten(arr) {\r\n            var flat = [];\r\n            for (var i = 0, n = arr.length; i < n; i++) {\r\n                flat = flat.concat(arr[i]);\r\n            }\r\n            return flat;\r\n        }\r\n\r\n        function _asyncEverySeries(arr, iterator, callback) {\r\n            if (!arr.length) {\r\n                return callback();\r\n            }\r\n            var completed = 0;\r\n            (function iterate() {\r\n                iterator(arr[completed], function(err) {\r\n                    if (err || err === false) {\r\n                        callback(err);\r\n                        callback = function() {};\r\n                    }\r\n                    else {\r\n                        completed += 1;\r\n                        if (completed === arr.length) {\r\n                            callback();\r\n                        }\r\n                        else {\r\n                            iterate();\r\n                        }\r\n                    }\r\n                });\r\n            })();\r\n        }\r\n\r\n        function paramifyString(str, params, mod) {\r\n            mod = str;\r\n            for (var param in params) {\r\n                if (params.hasOwnProperty(param)) {\r\n                    mod = params[param](str);\r\n                    if (mod !== str) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            return mod === str ? \"([._a-zA-Z0-9-]+)\" : mod;\r\n        }\r\n\r\n        function regifyString(str, params) {\r\n            var matches, last = 0,\r\n                out = \"\";\r\n            while (matches = str.substr(last).match(/[^\\w\\d\\- %@&]*\\*[^\\w\\d\\- %@&]*/)) {\r\n                last = matches.index + matches[0].length;\r\n                matches[0] = matches[0].replace(/^\\*/, \"([_.()!\\\\ %@&a-zA-Z0-9-]+)\");\r\n                out += str.substr(0, matches.index) + matches[0];\r\n            }\r\n            str = out += str.substr(last);\r\n            var captures = str.match(/:([^\\/]+)/ig),\r\n                length;\r\n            if (captures) {\r\n                length = captures.length;\r\n                for (var i = 0; i < length; i++) {\r\n                    str = str.replace(captures[i], paramifyString(captures[i], params));\r\n                }\r\n            }\r\n            return str;\r\n        }\r\n\r\n        function terminator(routes, delimiter, start, stop) {\r\n            var last = 0,\r\n                left = 0,\r\n                right = 0,\r\n                start = (start || \"(\").toString(),\r\n                stop = (stop || \")\").toString(),\r\n                i;\r\n            for (i = 0; i < routes.length; i++) {\r\n                var chunk = routes[i];\r\n                if (chunk.indexOf(start, last) > chunk.indexOf(stop, last) || ~chunk.indexOf(start, last) && !~chunk.indexOf(stop, last) || !~chunk.indexOf(start, last) && ~chunk.indexOf(stop, last)) {\r\n                    left = chunk.indexOf(start, last);\r\n                    right = chunk.indexOf(stop, last);\r\n                    if (~left && !~right || !~left && ~right) {\r\n                        var tmp = routes.slice(0, (i || 1) + 1).join(delimiter);\r\n                        routes = [tmp].concat(routes.slice((i || 1) + 1));\r\n                    }\r\n                    last = (right > left ? right : left) + 1;\r\n                    i = 0;\r\n                }\r\n                else {\r\n                    last = 0;\r\n                }\r\n            }\r\n            return routes;\r\n        }\r\n\r\n        Router.prototype.configure = function(options) {\r\n            options = options || {};\r\n            for (var i = 0; i < this.methods.length; i++) {\r\n                this._methods[this.methods[i]] = true;\r\n            }\r\n            this.recurse = options.recurse || this.recurse || false;\r\n            this.async = options.async || false;\r\n            this.delimiter = options.delimiter || \"/\";\r\n            this.strict = typeof options.strict === \"undefined\" ? true : options.strict;\r\n            this.notfound = options.notfound;\r\n            this.resource = options.resource;\r\n            this.history = options.html5history && this.historySupport || false;\r\n            this.run_in_init = this.history === true && options.run_handler_in_init !== false;\r\n            this.every = {\r\n                after: options.after || null,\r\n                before: options.before || null,\r\n                on: options.on || null\r\n            };\r\n            return this;\r\n        };\r\n\r\n        Router.prototype.param = function(token, matcher) {\r\n            if (token[0] !== \":\") {\r\n                token = \":\" + token;\r\n            }\r\n            var compiled = new RegExp(token, \"g\");\r\n            this.params[token] = function(str) {\r\n                return str.replace(compiled, matcher.source || matcher);\r\n            };\r\n        };\r\n\r\n        Router.prototype.on = Router.prototype.route = function(method, path, route) {\r\n            var self = this;\r\n            if (!route && typeof path == \"function\") {\r\n                route = path;\r\n                path = method;\r\n                method = \"on\";\r\n            }\r\n            if (Array.isArray(path)) {\r\n                return path.forEach(function(p) {\r\n                    self.on(method, p, route);\r\n                });\r\n            }\r\n            if (path.source) {\r\n                path = path.source.replace(/\\\\\\//ig, \"/\");\r\n            }\r\n            if (Array.isArray(method)) {\r\n                return method.forEach(function(m) {\r\n                    self.on(m.toLowerCase(), path, route);\r\n                });\r\n            }\r\n            path = path.split(new RegExp(this.delimiter));\r\n            path = terminator(path, this.delimiter);\r\n            this.insert(method, this.scope.concat(path), route);\r\n        };\r\n\r\n        Router.prototype.dispatch = function(method, path, callback) {\r\n            var self = this,\r\n                fns = this.traverse(method, path, this.routes, \"\"),\r\n                invoked = this._invoked,\r\n                after;\r\n            this._invoked = true;\r\n            if (!fns || fns.length === 0) {\r\n                this.last = [];\r\n                if (typeof this.notfound === \"function\") {\r\n                    this.invoke([this.notfound], {\r\n                        method: method,\r\n                        path: path\r\n                    }, callback);\r\n                }\r\n                return false;\r\n            }\r\n            if (this.recurse === \"forward\") {\r\n                fns = fns.reverse();\r\n            }\r\n\r\n            function updateAndInvoke() {\r\n                self.last = fns.after;\r\n                self.invoke(self.runlist(fns), self, callback);\r\n            }\r\n            after = this.every && this.every.after ? [this.every.after].concat(this.last) : [this.last];\r\n            if (after && after.length > 0 && invoked) {\r\n                if (this.async) {\r\n                    this.invoke(after, this, updateAndInvoke);\r\n                }\r\n                else {\r\n                    this.invoke(after, this);\r\n                    updateAndInvoke();\r\n                }\r\n                return true;\r\n            }\r\n            updateAndInvoke();\r\n            return true;\r\n        };\r\n\r\n        Router.prototype.invoke = function(fns, thisArg, callback) {\r\n            var self = this;\r\n            if (this.async) {\r\n                _asyncEverySeries(fns, function apply(fn, next) {\r\n                    if (Array.isArray(fn)) {\r\n                        return _asyncEverySeries(fn, apply, next);\r\n                    }\r\n                    else if (typeof fn == \"function\") {\r\n                        fn.apply(thisArg, fns.captures.concat(next));\r\n                    }\r\n                }, function() {\r\n                    if (callback) {\r\n                        callback.apply(thisArg, arguments);\r\n                    }\r\n                });\r\n            }\r\n            else {\r\n                _every(fns, function apply(fn) {\r\n                    if (Array.isArray(fn)) {\r\n                        return _every(fn, apply);\r\n                    }\r\n                    else if (typeof fn === \"function\") {\r\n                        return fn.apply(thisArg, fns.captures || []);\r\n                    }\r\n                    else if (typeof fn === \"string\" && self.resource) {\r\n                        self.resource[fn].apply(thisArg, fns.captures || []);\r\n                    }\r\n                });\r\n            }\r\n        };\r\n\r\n        Router.prototype.traverse = function(method, path, routes, regexp, filter) {\r\n            var fns = [],\r\n                current, exact, match, next, that;\r\n\r\n            function filterRoutes(routes) {\r\n                if (!filter) {\r\n                    return routes;\r\n                }\r\n\r\n                function deepCopy(source) {\r\n                    var result = [];\r\n                    for (var i = 0; i < source.length; i++) {\r\n                        result[i] = Array.isArray(source[i]) ? deepCopy(source[i]) : source[i];\r\n                    }\r\n                    return result;\r\n                }\r\n\r\n                function applyFilter(fns) {\r\n                    for (var i = fns.length - 1; i >= 0; i--) {\r\n                        if (Array.isArray(fns[i])) {\r\n                            applyFilter(fns[i]);\r\n                            if (fns[i].length === 0) {\r\n                                fns.splice(i, 1);\r\n                            }\r\n                        }\r\n                        else {\r\n                            if (!filter(fns[i])) {\r\n                                fns.splice(i, 1);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                var newRoutes = deepCopy(routes);\r\n                newRoutes.matched = routes.matched;\r\n                newRoutes.captures = routes.captures;\r\n                newRoutes.after = routes.after.filter(filter);\r\n                applyFilter(newRoutes);\r\n                return newRoutes;\r\n            }\r\n            if (path === this.delimiter && routes[method]) {\r\n                next = [\r\n                    [routes.before, routes[method]].filter(Boolean)];\r\n                next.after = [routes.after].filter(Boolean);\r\n                next.matched = true;\r\n                next.captures = [];\r\n                return filterRoutes(next);\r\n            }\r\n            for (var r in routes) {\r\n                if (routes.hasOwnProperty(r) && (!this._methods[r] || this._methods[r] && typeof routes[r] === \"object\" && !Array.isArray(routes[r]))) {\r\n                    current = exact = regexp + this.delimiter + r;\r\n                    if (!this.strict) {\r\n                        exact += \"[\" + this.delimiter + \"]?\";\r\n                    }\r\n                    match = path.match(new RegExp(\"^\" + exact));\r\n                    if (!match) {\r\n                        continue;\r\n                    }\r\n                    if (match[0] && match[0] == path && routes[r][method]) {\r\n                        next = [\r\n                            [routes[r].before, routes[r][method]].filter(Boolean)];\r\n                        next.after = [routes[r].after].filter(Boolean);\r\n                        next.matched = true;\r\n                        next.captures = match.slice(1);\r\n                        if (this.recurse && routes === this.routes) {\r\n                            next.push([routes.before, routes.on].filter(Boolean));\r\n                            next.after = next.after.concat([routes.after].filter(Boolean));\r\n                        }\r\n                        return filterRoutes(next);\r\n                    }\r\n                    next = this.traverse(method, path, routes[r], current);\r\n                    if (next.matched) {\r\n                        if (next.length > 0) {\r\n                            fns = fns.concat(next);\r\n                        }\r\n                        if (this.recurse) {\r\n                            fns.push([routes[r].before, routes[r].on].filter(Boolean));\r\n                            next.after = next.after.concat([routes[r].after].filter(Boolean));\r\n                            if (routes === this.routes) {\r\n                                fns.push([routes[\"before\"], routes[\"on\"]].filter(Boolean));\r\n                                next.after = next.after.concat([routes[\"after\"]].filter(Boolean));\r\n                            }\r\n                        }\r\n                        fns.matched = true;\r\n                        fns.captures = next.captures;\r\n                        fns.after = next.after;\r\n                        return filterRoutes(fns);\r\n                    }\r\n                }\r\n            }\r\n            return false;\r\n        };\r\n\r\n        Router.prototype.insert = function(method, path, route, parent) {\r\n            var methodType, parentType, isArray, nested, part;\r\n            path = path.filter(function(p) {\r\n                return p && p.length > 0;\r\n            });\r\n            parent = parent || this.routes;\r\n            part = path.shift();\r\n            if (/\\:|\\*/.test(part) && !/\\\\d|\\\\w/.test(part)) {\r\n                part = regifyString(part, this.params);\r\n            }\r\n            if (path.length > 0) {\r\n                parent[part] = parent[part] || {};\r\n                return this.insert(method, path, route, parent[part]);\r\n            }\r\n            if (!part && !path.length && parent === this.routes) {\r\n                methodType = typeof parent[method];\r\n                switch (methodType) {\r\n                case \"function\":\r\n                    parent[method] = [parent[method], route];\r\n                    return;\r\n                case \"object\":\r\n                    parent[method].push(route);\r\n                    return;\r\n                case \"undefined\":\r\n                    parent[method] = route;\r\n                    return;\r\n                }\r\n                return;\r\n            }\r\n            parentType = typeof parent[part];\r\n            isArray = Array.isArray(parent[part]);\r\n            if (parent[part] && !isArray && parentType == \"object\") {\r\n                methodType = typeof parent[part][method];\r\n                switch (methodType) {\r\n                case \"function\":\r\n                    parent[part][method] = [parent[part][method], route];\r\n                    return;\r\n                case \"object\":\r\n                    parent[part][method].push(route);\r\n                    return;\r\n                case \"undefined\":\r\n                    parent[part][method] = route;\r\n                    return;\r\n                }\r\n            }\r\n            else if (parentType == \"undefined\") {\r\n                nested = {};\r\n                nested[method] = route;\r\n                parent[part] = nested;\r\n                return;\r\n            }\r\n            throw new Error(\"Invalid route context: \" + parentType);\r\n        };\r\n\r\n\r\n\r\n        Router.prototype.extend = function(methods) {\r\n            var self = this,\r\n                len = methods.length,\r\n                i;\r\n\r\n            function extend(method) {\r\n                self._methods[method] = true;\r\n                self[method] = function() {\r\n                    var extra = arguments.length === 1 ? [method, \"\"] : [method];\r\n                    self.on.apply(self, extra.concat(Array.prototype.slice.call(arguments)));\r\n                };\r\n            }\r\n            for (i = 0; i < len; i++) {\r\n                extend(methods[i]);\r\n            }\r\n        };\r\n\r\n        Router.prototype.runlist = function(fns) {\r\n            var runlist = this.every && this.every.before ? [this.every.before].concat(_flatten(fns)) : _flatten(fns);\r\n            if (this.every && this.every.on) {\r\n                runlist.push(this.every.on);\r\n            }\r\n            runlist.captures = fns.captures;\r\n            runlist.source = fns.source;\r\n            return runlist;\r\n        };\r\n\r\n        Router.prototype.mount = function(routes, path) {\r\n            if (!routes || typeof routes !== \"object\" || Array.isArray(routes)) {\r\n                return;\r\n            }\r\n            var self = this;\r\n            path = path || [];\r\n            if (!Array.isArray(path)) {\r\n                path = path.split(self.delimiter);\r\n            }\r\n\r\n            function insertOrMount(route, local) {\r\n                var rename = route,\r\n                    parts = route.split(self.delimiter),\r\n                    routeType = typeof routes[route],\r\n                    isRoute = parts[0] === \"\" || !self._methods[parts[0]],\r\n                    event = isRoute ? \"on\" : rename;\r\n                if (isRoute) {\r\n                    rename = rename.slice((rename.match(new RegExp(self.delimiter)) || [\"\"])[0].length);\r\n                    parts.shift();\r\n                }\r\n                if (isRoute && routeType === \"object\" && !Array.isArray(routes[route])) {\r\n                    local = local.concat(parts);\r\n                    self.mount(routes[route], local);\r\n                    return;\r\n                }\r\n                if (isRoute) {\r\n                    local = local.concat(rename.split(self.delimiter));\r\n                    local = terminator(local, self.delimiter);\r\n                }\r\n                self.insert(event, local, routes[route]);\r\n            }\r\n            for (var route in routes) {\r\n                if (routes.hasOwnProperty(route)) {\r\n                    insertOrMount(route, path.slice(0));\r\n                }\r\n            }\r\n        };\r\n\r\n        \r\n\r\n    \r\n    return {\r\n            Router: Router\r\n        };});"]],"start1":0,"start2":0,"length1":0,"length2":28639}]],"length":28639}

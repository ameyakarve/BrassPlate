{"ts":1362117676421,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n// ==========================================\n// Copyright 2013 Twitter, Inc\n// Licensed under The MIT License\n// http://opensource.org/licenses/MIT\n// ==========================================\n\n\n\ndefine('assets/js/components/flight/lib/utils',\n\n  [],\n\n  function () {\n\n    var arry = [];\n    var DEFAULT_INTERVAL = 100;\n\n    var utils = {\n\n      isDomObj: function(obj) {\n        return !!(obj.nodeType || (obj === window));\n      },\n\n      toArray: function(obj, from) {\n        return arry.slice.call(obj, from);\n      },\n\n      // returns new object representing multiple objects merged together\n      // optional final argument is boolean which specifies if merge is recursive\n      // original objects are unmodified\n      //\n      // usage:\n      //   var base = {a:2, b:6};\n      //   var extra = {b:3, c:4};\n      //   merge(base, extra); //{a:2, b:3, c:4}\n      //   base; //{a:2, b:6}\n      //\n      //   var base = {a:2, b:6};\n      //   var extra = {b:3, c:4};\n      //   var extraExtra = {a:4, d:9};\n      //   merge(base, extra, extraExtra); //{a:4, b:3, c:4. d: 9}\n      //   base; //{a:2, b:6}\n      //\n      //   var base = {a:2, b:{bb:4, cc:5}};\n      //   var extra = {a:4, b:{cc:7, dd:1}};\n      //   merge(base, extra, true); //{a:4, b:{bb:4, cc:7, dd:1}}\n      //   base; //{a:2, b:6}\n\n      merge: function(/*obj1, obj2,....deepCopy*/) {\n        var args = this.toArray(arguments);\n\n        //start with empty object so a copy is created\n        args.unshift({});\n\n        if (args[args.length - 1] === true) {\n          //jquery extend requires deep copy as first arg\n          args.pop();\n          args.unshift(true);\n        }\n\n        return $.extend.apply(undefined, args);\n      },\n\n      // updates base in place by copying properties of extra to it\n      // optionally clobber protected\n      // usage:\n      //   var base = {a:2, b:6};\n      //   var extra = {c:4};\n      //   push(base, extra); //{a:2, b:6, c:4}\n      //   base; //{a:2, b:6, c:4}\n      //\n      //   var base = {a:2, b:6};\n      //   var extra = {b: 4 c:4};\n      //   push(base, extra, true); //Error (\"utils.push attempted to overwrite 'b' while running in protected mode\")\n      //   base; //{a:2, b:6}\n      //\n      // objects with the same key will merge recursively when protect is false\n      // eg:\n      // var base = {a:16, b:{bb:4, cc:10}};\n      // var extra = {b:{cc:25, dd:19}, c:5};\n      // push(base, extra); //{a:16, {bb:4, cc:25, dd:19}, c:5}\n      //\n      push: function(base, extra, protect) {\n        if (base) {\n          Object.keys(extra || {}).forEach(function(key) {\n            if (base[key] && protect) {\n              throw Error(\"utils.push attempted to overwrite '\" + key + \"' while running in protected mode\");\n            }\n\n            if (typeof base[key] == \"object\" && typeof extra[key] == \"object\") {\n              //recurse\n              this.push(base[key], extra[key]);\n            } else {\n              //no protect, so extra wins\n              base[key] = extra[key];\n            }\n          }, this);\n        }\n\n        return base;\n      },\n\n      isEnumerable: function(obj, property) {\n        return Object.keys(obj).indexOf(property) > -1;\n      },\n\n      //build a function from other function(s)\n      //util.compose(a,b,c) -> a(b(c()));\n      //implementation lifted from underscore.js (c) 2009-2012 Jeremy Ashkenas\n      compose: function() {\n        var funcs = arguments;\n\n        return function() {\n          var args = arguments;\n\n          for (var i = funcs.length-1; i >= 0; i--) {\n            args = [funcs[i].apply(this, args)];\n          }\n\n          return args[0];\n        };\n      },\n\n      // Can only unique arrays of homogeneous primitives, e.g. an array of only strings, an array of only booleans, or an array of only numerics\n      uniqueArray: function(array) {\n        var u = {}, a = [];\n\n        for (var i = 0, l = array.length; i < l; ++i) {\n          if (u.hasOwnProperty(array[i])) {\n            continue;\n          }\n\n          a.push(array[i]);\n          u[array[i]] = 1;\n        }\n\n        return a;\n      },\n\n      debounce: function(func, wait, immediate) {\n        if (typeof wait != 'number') {\n          wait = DEFAULT_INTERVAL;\n        }\n\n        var timeout, result;\n\n        return function() {\n          var context = this, args = arguments;\n          var later = function() {\n            timeout = null;\n            if (!immediate) {\n              result = func.apply(context, args);\n            }\n          };\n          var callNow = immediate && !timeout;\n\n          clearTimeout(timeout);\n          timeout = setTimeout(later, wait);\n\n          if (callNow) {\n            result = func.apply(context, args);\n          }\n\n          return result;\n        };\n      },\n\n      throttle: function(func, wait) {\n        if (typeof wait != 'number') {\n          wait = DEFAULT_INTERVAL;\n        }\n\n        var context, args, timeout, throttling, more, result;\n        var whenDone = this.debounce(function(){\n          more = throttling = false;\n        }, wait);\n\n        return function() {\n          context = this; args = arguments;\n          var later = function() {\n            timeout = null;\n            if (more) {\n              result = func.apply(context, args);\n            }\n            whenDone();\n          };\n\n          if (!timeout) {\n            timeout = setTimeout(later, wait);\n          }\n\n          if (throttling) {\n            more = true;\n          } else {\n            throttling = true;\n            result = func.apply(context, args);\n          }\n\n          whenDone();\n          return result;\n        };\n      },\n\n      countThen: function(num, base) {\n        return function() {\n          if (!--num) { return base.apply(this, arguments); }\n        };\n      },\n\n      delegate: function(rules) {\n        return function(e, data) {\n          var target = $(e.target), parent;\n\n          Object.keys(rules).forEach(function(selector) {\n            if ((parent = target.closest(selector)).length) {\n              data = data || {};\n              data.el = parent[0];\n              return rules[selector].apply(this, [e, data]);\n            }\n          }, this);\n        };\n      }\n\n    };\n\n    return utils;\n  }\n);\n\n// ==========================================\n// Copyright 2013 Twitter, Inc\n// Licensed under The MIT License\n// http://opensource.org/licenses/MIT\n// ==========================================\n\n\n\ndefine('assets/js/components/flight/lib/registry',\n\n  [\n    './utils'\n  ],\n\n  function (util) {\n\n    function parseEventArgs(instance, args) {\n      var element, type, callback;\n\n      args = util.toArray(args);\n\n      if (typeof args[args.length-1] === 'function') {\n        callback = args.pop();\n      }\n\n      if (typeof args[args.length-1] === 'object') {\n        args.pop();\n      }\n\n      if (args.length == 2) {\n        element = args[0];\n        type = args[1];\n      } else {\n        element = instance.node;\n        type = args[0];\n      }\n\n      return {\n        element: element,\n        type: type,\n        callback: callback\n      };\n    }\n\n    function matchEvent(a, b) {\n      return (\n        (a.element == b.element) &&\n        (a.type == b.type) &&\n        (b.callback == null || (a.callback == b.callback))\n      );\n    }\n\n    function Registry() {\n\n      var registry = this;\n\n      (this.reset = function() {\n        this.components = [];\n        this.allInstances = [];\n        this.events = [];\n      }).call(this);\n\n      function ComponentInfo(component) {\n        this.component = component;\n        this.instances = [];\n\n        this.addInstance = function(instance) {\n          this.throwIfInstanceExistsOnNode(instance);\n\n          var instanceInfo = new InstanceInfo(instance);\n          this.instances.push(instanceInfo);\n\n          return instanceInfo;\n        }\n\n        this.throwIfInstanceExistsOnNode = function(instance) {\n          this.instances.forEach(function (instanceInfo) {\n            if (instanceInfo.instance.$node[0] === instance.$node[0]) {\n              throw new Error('Instance of ' + instance.constructor + ' already exists on node ' + instance.$node[0]);\n            }\n          });\n        }\n\n        this.removeInstance = function(instance) {\n          var instanceInfo = this.instances.filter(function(instanceInfo) {\n            return instanceInfo.instance == instance;\n          })[0];\n\n          var index = this.instances.indexOf(instanceInfo);\n\n          (index > -1)  && this.instances.splice(index, 1);\n\n          if (!this.instances.length) {\n            //if I hold no more instances remove me from registry\n            registry.removeComponentInfo(this);\n          }\n        }\n      }\n\n      function InstanceInfo(instance) {\n        this.instance = instance;\n        this.events = [];\n\n        this.addTrigger = function() {};\n\n        this.addBind = function(event) {\n          this.events.push(event);\n          registry.events.push(event);\n        };\n\n        this.removeBind = function(event) {\n          for (var i = 0, e; e = this.events[i]; i++) {\n            if (matchEvent(e, event)) {\n              this.events.splice(i, 1);\n            }\n          }\n        }\n      }\n\n      this.addInstance = function(instance) {\n        var component = this.findComponentInfo(instance);\n\n        if (!component) {\n          component = new ComponentInfo(instance.constructor);\n          this.components.push(component);\n        }\n\n        var inst = component.addInstance(instance);\n\n        this.allInstances.push(inst);\n\n        return component;\n      };\n\n      this.removeInstance = function(instance) {\n        var index, instInfo = this.findInstanceInfo(instance);\n\n        //remove from component info\n        var componentInfo = this.findComponentInfo(instance);\n        componentInfo.removeInstance(instance);\n\n        //remove from registry\n        var index = this.allInstances.indexOf(instInfo);\n        (index > -1)  && this.allInstances.splice(index, 1);\n      };\n\n      this.removeComponentInfo = function(componentInfo) {\n        var index = this.components.indexOf(componentInfo);\n        (index > -1)  && this.components.splice(index, 1);\n      };\n\n      this.findComponentInfo = function(which) {\n        var component = which.attachTo ? which : which.constructor;\n\n        for (var i = 0, c; c = this.components[i]; i++) {\n          if (c.component === component) {\n            return c;\n          }\n        }\n\n        return null;\n      };\n\n      this.findInstanceInfo = function(which) {\n        var testFn;\n\n        if (which.node) {\n          //by instance (returns matched instance)\n          testFn = function(inst) {return inst.instance === which};\n        } else {\n          //by node (returns array of matches)\n          testFn = function(inst) {return inst.instance.node === which};\n        }\n\n        var matches = this.allInstances.filter(testFn);\n        if (!matches.length) {\n          return which.node ? null : [];\n        }\n        return which.node ? matches[0] : matches;\n      };\n\n      this.trigger = function() {\n        var event = parseEventArgs(this, arguments),\n            instance = registry.findInstanceInfo(this);\n\n        if (instance) {\n          instance.addTrigger(event);\n        }\n      };\n\n      this.on = function(componentOn) {\n        var otherArgs = util.toArray(arguments, 1);\n        var instance = registry.findInstanceInfo(this);\n        var boundCallback;\n\n        if (instance) {\n          boundCallback = componentOn.apply(null, otherArgs);\n          if(boundCallback) {\n            otherArgs[otherArgs.length-1] = boundCallback;\n          }\n          var event = parseEventArgs(this, otherArgs);\n          instance.addBind(event);\n        }\n      };\n\n      this.off = function(el, type, callback) {\n        var event = parseEventArgs(this, arguments),\n            instance = registry.findInstanceInfo(this);\n\n        if (instance) {\n          instance.removeBind(event);\n        }\n      };\n\n      this.teardown = function() {\n        registry.removeInstance(this);\n      };\n\n      this.withRegistration = function() {\n        this.before('initialize', function() {\n          registry.addInstance(this);\n        });\n\n        this.after('trigger', registry.trigger);\n        this.around('on', registry.on);\n        this.after('off', registry.off);\n        this.after('teardown', {obj:registry, fnName:'teardown'});\n      };\n\n    }\n\n    return new Registry;\n  }\n);\n\n\n\ndefine('assets/js/components/flight/tools/debug/debug',\n\n  [\n    '../../lib/registry',\n    '../../lib/utils'\n  ],\n\n  function(registry, utils) {\n\n    var logFilter;\n\n    //******************************************************************************************\n    // Search object model\n    //******************************************************************************************\n\n    function traverse(util, searchTerm, options) {\n      var options = options || {};\n      var obj = options.obj || window;\n      var path = options.path || ((obj==window) ? \"window\" : \"\");\n      var props = Object.keys(obj);\n      props.forEach(function(prop) {\n        if ((tests[util] || util)(searchTerm, obj, prop)){\n          console.log([path, \".\", prop].join(\"\"), \"->\",[\"(\", typeof obj[prop], \")\"].join(\"\"), obj[prop]);\n        }\n        if(Object.prototype.toString.call(obj[prop])==\"[object Object]\" && (obj[prop] != obj) && path.split(\".\").indexOf(prop) == -1) {\n          traverse(util, searchTerm, {obj: obj[prop], path: [path,prop].join(\".\")});\n        }\n      });\n    }\n\n    function search(util, expected, searchTerm, options) {\n      if (!expected || typeof searchTerm == expected) {\n        traverse(util, searchTerm, options);\n      } else {\n        console.error([searchTerm, 'must be', expected].join(' '))\n      }\n    }\n\n    var tests = {\n      'name': function(searchTerm, obj, prop) {return searchTerm == prop},\n      'nameContains': function(searchTerm, obj, prop) {return prop.indexOf(searchTerm)>-1},\n      'type': function(searchTerm, obj, prop) {return obj[prop] instanceof searchTerm},\n      'value': function(searchTerm, obj, prop) {return obj[prop] === searchTerm},\n      'valueCoerced': function(searchTerm, obj, prop) {return obj[prop] == searchTerm}\n    }\n\n    function byName(searchTerm, options) {search('name', 'string', searchTerm, options);};\n    function byNameContains(searchTerm, options) {search('nameContains', 'string', searchTerm, options);};\n    function byType(searchTerm, options) {search('type', 'function', searchTerm, options);};\n    function byValue(searchTerm, options) {search('value', null, searchTerm, options);};\n    function byValueCoerced(searchTerm, options) {search('valueCoerced', null, searchTerm, options);};\n    function custom(fn, options) {traverse(fn, null, options);};\n\n    //******************************************************************************************\n    // Event logging\n    //******************************************************************************************\n    var logLevel = 'all';\n    logFilter = {actions: logLevel, eventNames: logLevel}; //no filter by default\n\n    function filterEventLogsByAction(/*actions*/) {\n      var actions = [].slice.call(arguments, 0);\n\n      logFilter.eventNames.length || (logFilter.eventNames = 'all');\n      logFilter.actions = actions.length ? actions : 'all';\n    }\n\n    function filterEventLogsByName(/*eventNames*/) {\n      var eventNames = [].slice.call(arguments, 0);\n\n      logFilter.actions.length || (logFilter.actions = 'all');\n      logFilter.eventNames = eventNames.length ? eventNames : 'all';\n    }\n\n    function hideAllEventLogs() {\n      logFilter.actions = [];\n      logFilter.eventNames = [];\n    }\n\n    function showAllEventLogs() {\n      logFilter.actions = 'all';\n      logFilter.eventNames = 'all';\n    }\n\n    return {\n\n      enable: function(enable) {\n        this.enabled = !!enable;\n\n        if (enable && window.console) {\n          console.info('Booting in DEBUG mode');\n          console.info('You can filter event logging with DEBUG.events.logAll/logNone/logByName/logByAction');\n        }\n\n        window.DEBUG = this;\n      },\n\n      find: {\n        byName: byName,\n        byNameContains: byNameContains,\n        byType: byType,\n        byValue: byValue,\n        byValueCoerced: byValueCoerced,\n        custom: custom\n      },\n\n      events: {\n        logFilter: logFilter,\n\n        // Accepts any number of action args\n        // e.g. DEBUG.events.logByAction(\"on\", \"off\")\n        logByAction: filterEventLogsByAction,\n\n        // Accepts any number of event name args (inc. regex or wildcards)\n        // e.g. DEBUG.events.logByName(/ui.*/, \"*Thread*\");\n        logByName: filterEventLogsByName,\n\n        logAll: showAllEventLogs,\n        logNone: hideAllEventLogs\n      }\n    };\n  }\n);\n\n\n// ==========================================\n// Copyright 2013 Twitter, Inc\n// Licensed under The MIT License\n// http://opensource.org/licenses/MIT\n// ==========================================\n\n\n\ndefine('assets/js/components/flight/lib/compose',\n\n  [\n    './utils',\n    '../tools/debug/debug'\n  ],\n\n  function(util, debug) {\n\n    //enumerables are shims - getOwnPropertyDescriptor shim doesn't work\n    var canWriteProtect = debug.enabled && !util.isEnumerable(Object, 'getOwnPropertyDescriptor');\n    //whitelist of unlockable property names\n    var dontLock = ['mixedIn'];\n\n    if (canWriteProtect) {\n      //IE8 getOwnPropertyDescriptor is built-in but throws exeption on non DOM objects\n      try {\n        Object.getOwnPropertyDescriptor(Object, 'keys');\n      } catch(e) {\n        canWriteProtect = false;\n      }\n    }\n\n    function setPropertyWritability(obj, isWritable) {\n      if (!canWriteProtect) {\n        return;\n      }\n\n      var props = Object.create(null);\n\n      Object.keys(obj).forEach(\n        function (key) {\n          if (dontLock.indexOf(key) < 0) {\n            var desc = Object.getOwnPropertyDescriptor(obj, key);\n            desc.writable = isWritable;\n            props[key] = desc;\n          }\n        }\n      );\n\n      Object.defineProperties(obj, props);\n    }\n\n    function unlockProperty(obj, prop, op) {\n      var writable;\n\n      if (!canWriteProtect || !obj.hasOwnProperty(prop)) {\n        op.call(obj);\n        return;\n      }\n\n      writable = Object.getOwnPropertyDescriptor(obj, prop).writable;\n      Object.defineProperty(obj, prop, { writable: true });\n      op.call(obj);\n      Object.defineProperty(obj, prop, { writable: writable });\n    }\n\n    function mixin(base, mixins) {\n      base.mixedIn = base.hasOwnProperty('mixedIn') ? base.mixedIn : [];\n\n      mixins.forEach(function(mixin) {\n        if (base.mixedIn.indexOf(mixin) == -1) {\n          setPropertyWritability(base, false);\n          mixin.call(base);\n          base.mixedIn.push(mixin);\n        }\n      });\n\n      setPropertyWritability(base, true);\n    }\n\n    return {\n      mixin: mixin,\n      unlockProperty: unlockProperty\n    };\n\n  }\n);\n\n// ==========================================\n// Copyright 2013 Twitter, Inc\n// Licensed under The MIT License\n// http://opensource.org/licenses/MIT\n// ==========================================\n\n\n\ndefine('assets/js/components/flight/lib/advice',\n\n  [\n    './utils',\n    './compose'\n  ],\n\n  function (util, compose) {\n\n    var advice = {\n\n      around: function(base, wrapped) {\n        return function() {\n          var args = util.toArray(arguments);\n          return wrapped.apply(this, [base.bind(this)].concat(args));\n        }\n      },\n\n      before: function(base, before) {\n        return this.around(base, function() {\n          var args = util.toArray(arguments),\n              orig = args.shift(),\n              beforeFn;\n\n          beforeFn = (typeof before == 'function') ? before : before.obj[before.fnName];\n          beforeFn.apply(this, args);\n          return (orig).apply(this, args);\n        });\n      },\n\n      after: function(base, after) {\n        return this.around(base, function() {\n          var args = util.toArray(arguments),\n              orig = args.shift(),\n              afterFn;\n\n          // this is a separate statement for debugging purposes.\n          var res = (orig.unbound || orig).apply(this, args);\n\n          afterFn = (typeof after == 'function') ? after : after.obj[after.fnName];\n          afterFn.apply(this, args);\n          return res;\n        });\n      },\n\n      // a mixin that allows other mixins to augment existing functions by adding additional\n      // code before, after or around.\n      withAdvice: function() {\n        ['before', 'after', 'around'].forEach(function(m) {\n          this[m] = function(method, fn) {\n\n            compose.unlockProperty(this, method, function() {\n              if (typeof this[method] == 'function') {\n                return this[method] = advice[m](this[method], fn);\n              } else {\n                return this[method] = fn;\n              }\n            });\n\n          };\n        }, this);\n      }\n    };\n\n    return advice;\n  }\n);\n\n// ==========================================\n// Copyright 2013 Twitter, Inc\n// Licensed under The MIT License\n// http://opensource.org/licenses/MIT\n// ==========================================\n\n\n\ndefine('assets/js/components/flight/lib/component',\n\n  [\n    './advice',\n    './utils',\n    './compose',\n    './registry'\n  ],\n\n  function(advice, utils, compose, registry) {\n\n    var functionNameRegEx = /function (.*?)\\s?\\(/;\n    var spaceCommaRegEx = /\\s\\,/g;\n\n    function teardownInstance(instanceInfo){\n      instanceInfo.events.slice().forEach(function(event) {\n        var args = [event.type];\n\n        event.element && args.unshift(event.element);\n        (typeof event.callback == 'function') && args.push(event.callback);\n\n        this.off.apply(this, args);\n      }, instanceInfo.instance);\n    }\n\n\n    function teardown() {\n      this.trigger(\"componentTearDown\");\n      teardownInstance(registry.findInstanceInfo(this));\n    }\n\n    //teardown for all instances of this constructor\n    function teardownAll() {\n      var componentInfo = registry.findComponentInfo(this);\n\n      componentInfo && componentInfo.instances.slice().forEach(function(info) {\n        info.instance.teardown();\n      });\n    }\n\n    function checkSerializable(type, data) {\n      try {\n        window.postMessage(data, '*');\n      } catch(e) {\n        console.log('unserializable data for event',type,':',data);\n        throw new Error(\n          [\"The event\", type, \"on component\", this.describe, \"was triggered with non-serializable data\"].join(\" \")\n        );\n      }\n    }\n\n    //common mixin allocates basic functionality - used by all component prototypes\n    //callback context is bound to component\n    function withBaseComponent() {\n\n      // delegate trigger, bind and unbind to an element\n      // if $element not supplied, use component's node\n      // other arguments are passed on\n      // event can be either a string specifying the type\n      // of the event, or a hash specifying both the type\n      // and a default function to be called.\n      this.trigger = function() {\n        var $element, type, data, event, defaultFn;\n        var args = utils.toArray(arguments);\n        var lastArg = args[args.length - 1];\n\n        if (typeof lastArg != \"string\" && !(lastArg && lastArg.defaultBehavior)) {\n          data = args.pop();\n        }\n\n        $element = (args.length == 2) ? $(args.shift()) : this.$node;\n        event = args[0];\n\n        if (event.defaultBehavior) {\n          defaultFn = event.defaultBehavior;\n          event = $.Event(event.type);\n        }\n\n        type = event.type || event;\n\n        if (window.DEBUG && window.postMessage) {\n          checkSerializable.call(this, type, data);\n        }\n\n        if (typeof this.attr.eventData === 'object') {\n          data = $.extend(true, {}, this.attr.eventData, data);\n        }\n\n        var returnVal = $element.trigger((event || type), data);\n\n        if (defaultFn && !event.isDefaultPrevented()) {\n          (this[defaultFn] || defaultFn).call(this);\n        }\n\n        return returnVal;\n      };\n\n      this.on = function() {\n        var $element, type, callback, originalCb;\n        var args = utils.toArray(arguments);\n\n        if (typeof args[args.length - 1] == \"object\") {\n          //delegate callback\n          originalCb = utils.delegate(\n            this.resolveDelegateRules(args.pop())\n          );\n        } else {\n          originalCb = args.pop();\n        }\n\n        $element = (args.length == 2) ? $(args.shift()) : this.$node;\n        type = args[0];\n\n        if (typeof originalCb != 'function' && typeof originalCb != 'object') {\n          throw new Error(\"Unable to bind to '\" + type + \"' because the given callback is not a function or an object\");\n        }\n\n        callback = originalCb.bind(this);\n        callback.target = originalCb;\n\n        // if the original callback is already branded by jQuery's guid, copy it to the context-bound version\n        if (originalCb.guid) {\n          callback.guid = originalCb.guid;\n        }\n\n        $element.on(type, callback);\n\n        // get jquery's guid from our bound fn, so unbinding will work\n        originalCb.guid = callback.guid;\n\n        return callback;\n      };\n\n      this.off = function() {\n        var $element, type, callback;\n        var args = utils.toArray(arguments);\n\n        if (typeof args[args.length - 1] == \"function\") {\n          callback = args.pop();\n        }\n\n        $element = (args.length == 2) ? $(args.shift()) : this.$node;\n        type = args[0];\n\n        return $element.off(type, callback);\n      };\n\n      this.resolveDelegateRules = function(ruleInfo) {\n        var rules = {};\n\n        Object.keys(ruleInfo).forEach(\n          function(r) {\n            if (!this.attr.hasOwnProperty(r)) {\n              throw new Error('Component \"' + this.describe + '\" wants to listen on \"' + r + '\" but no such attribute was defined.');\n            }\n            rules[this.attr[r]] = ruleInfo[r];\n          },\n          this\n        );\n\n        return rules;\n      };\n\n      this.defaultAttrs = function(defaults) {\n        utils.push(this.defaults, defaults, true) || (this.defaults = defaults);\n      };\n\n      this.select = function(attributeKey) {\n        return this.$node.find(this.attr[attributeKey]);\n      };\n\n      this.initialize = $.noop;\n      this.teardown = teardown;\n    }\n\n    function attachTo(selector/*, options args */) {\n      if (!selector) {\n        throw new Error(\"Component needs to be attachTo'd a jQuery object, native node or selector string\");\n      }\n\n      var options = utils.merge.apply(utils, utils.toArray(arguments, 1));\n\n      $(selector).each(function(i, node) {\n        new this(node, options);\n      }.bind(this));\n    }\n\n    // define the constructor for a custom component type\n    // takes an unlimited number of mixin functions as arguments\n    // typical api call with 3 mixins: define(timeline, withTweetCapability, withScrollCapability);\n    function define(/*mixins*/) {\n      var mixins = utils.toArray(arguments);\n\n      Component.toString = function() {\n        var prettyPrintMixins = mixins.map(function(mixin) {\n          if ($.browser.msie) {\n            var m = mixin.toString().match(functionNameRegEx);\n            return (m && m[1]) ? m[1] : \"\";\n          } else {\n            return mixin.name;\n          }\n        }).join(', ').replace(spaceCommaRegEx,'');//weed out no-named mixins\n\n        return prettyPrintMixins;\n      };\n\n      Component.describe = Component.toString();\n\n      //'options' is optional hash to be merged with 'defaults' in the component definition\n      function Component(node, options) {\n        var fnCache = {}, uuid = 0;\n\n        if (!node) {\n          throw new Error(\"Component needs a node\");\n        }\n\n        if (node.jquery) {\n          this.node = node[0];\n          this.$node = node;\n        } else {\n          this.node = node;\n          this.$node = $(node);\n        }\n\n        this.describe = this.constructor.describe;\n\n        this.bind = function(func) {\n          var bound;\n\n          if (func.uuid && (bound = fnCache[func.uuid])) {\n            return bound;\n          }\n\n          var bindArgs = utils.toArray(arguments, 1);\n          bindArgs.unshift(this); //prepend context\n\n          bound = func.bind.apply(func, bindArgs);\n          bound.target = func;\n          func.uuid = uuid++;\n          fnCache[func.uuid] = bound;\n\n          return bound;\n        };\n\n        //merge defaults with supplied options\n        this.attr = utils.merge(this.defaults, options);\n        this.defaults && Object.keys(this.defaults).forEach(function(key) {\n          if (this.defaults[key] === null && this.attr[key] === null) {\n            throw new Error('Required attribute \"' + key + '\" not specified in attachTo for component \"' + this.describe + '\".');\n          }\n        }, this);\n\n        this.initialize.call(this, options || {});\n\n        this.trigger('componentInitialized');\n      }\n\n      Component.attachTo = attachTo;\n      Component.teardownAll = teardownAll;\n\n      // prepend common mixins to supplied list, then mixin all flavors\n      mixins.unshift(withBaseComponent, advice.withAdvice, registry.withRegistration);\n\n      compose.mixin(Component.prototype, mixins);\n\n      return Component;\n    }\n\n    define.teardownAll = function() {\n      registry.components.slice().forEach(function(c) {\n        c.component.teardownAll();\n      });\n      registry.reset();\n    };\n\n    return define;\n  }\n);\n\ndefine('assets/js/components/bootstrap/js/bootstrap-combined',['jquery'], function ($) {\n    //Plugin code goes here.\n/* =========================================================\n * bootstrap-modal.js v2.3.0\n * http://twitter.github.com/bootstrap/javascript.html#modals\n * =========================================================\n * Copyright 2012 Twitter, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ========================================================= */\n\n\n!function ($) {\n\n   // jshint ;_;\n\n\n /* MODAL CLASS DEFINITION\n  * ====================== */\n\n  var Modal = function (element, options) {\n    this.options = options\n    this.$element = $(element)\n      .delegate('[data-dismiss=\"modal\"]', 'click.dismiss.modal', $.proxy(this.hide, this))\n    this.options.remote && this.$element.find('.modal-body').load(this.options.remote)\n  }\n\n  Modal.prototype = {\n\n      constructor: Modal\n\n    , toggle: function () {\n        return this[!this.isShown ? 'show' : 'hide']()\n      }\n\n    , show: function () {\n        var that = this\n          , e = $.Event('show')\n\n        this.$element.trigger(e)\n\n        if (this.isShown || e.isDefaultPrevented()) return\n\n        this.isShown = true\n\n        this.escape()\n\n        this.backdrop(function () {\n          var transition = $.support.transition && that.$element.hasClass('fade')\n\n          if (!that.$element.parent().length) {\n            that.$element.appendTo(document.body) //don't move modals dom position\n          }\n\n          that.$element.show()\n\n          if (transition) {\n            that.$element[0].offsetWidth // force reflow\n          }\n\n          that.$element\n            .addClass('in')\n            .attr('aria-hidden', false)\n\n          that.enforceFocus()\n\n          transition ?\n            that.$element.one($.support.transition.end, function () { that.$element.focus().trigger('shown') }) :\n            that.$element.focus().trigger('shown')\n\n        })\n      }\n\n    , hide: function (e) {\n        e && e.preventDefault()\n\n        var that = this\n\n        e = $.Event('hide')\n\n        this.$element.trigger(e)\n\n        if (!this.isShown || e.isDefaultPrevented()) return\n\n        this.isShown = false\n\n        this.escape()\n\n        $(document).off('focusin.modal')\n\n        this.$element\n          .removeClass('in')\n          .attr('aria-hidden', true)\n\n        $.support.transition && this.$element.hasClass('fade') ?\n          this.hideWithTransition() :\n          this.hideModal()\n      }\n\n    , enforceFocus: function () {\n        var that = this\n        $(document).on('focusin.modal', function (e) {\n          if (that.$element[0] !== e.target && !that.$element.has(e.target).length) {\n            that.$element.focus()\n          }\n        })\n      }\n\n    , escape: function () {\n        var that = this\n        if (this.isShown && this.options.keyboard) {\n          this.$element.on('keyup.dismiss.modal', function ( e ) {\n            e.which == 27 && that.hide()\n          })\n        } else if (!this.isShown) {\n          this.$element.off('keyup.dismiss.modal')\n        }\n      }\n\n    , hideWithTransition: function () {\n        var that = this\n          , timeout = setTimeout(function () {\n              that.$element.off($.support.transition.end)\n              that.hideModal()\n            }, 500)\n\n        this.$element.one($.support.transition.end, function () {\n          clearTimeout(timeout)\n          that.hideModal()\n        })\n      }\n\n    , hideModal: function () {\n        var that = this\n        this.$element.hide()\n        this.backdrop(function () {\n          that.removeBackdrop()\n          that.$element.trigger('hidden')\n        })\n      }\n\n    , removeBackdrop: function () {\n        this.$backdrop.remove()\n        this.$backdrop = null\n      }\n\n    , backdrop: function (callback) {\n        var that = this\n          , animate = this.$element.hasClass('fade') ? 'fade' : ''\n\n        if (this.isShown && this.options.backdrop) {\n          var doAnimate = $.support.transition && animate\n\n          this.$backdrop = $('<div class=\"modal-backdrop ' + animate + '\" />')\n            .appendTo(document.body)\n\n          this.$backdrop.click(\n            this.options.backdrop == 'static' ?\n              $.proxy(this.$element[0].focus, this.$element[0])\n            : $.proxy(this.hide, this)\n          )\n\n          if (doAnimate) this.$backdrop[0].offsetWidth // force reflow\n\n          this.$backdrop.addClass('in')\n\n          if (!callback) return\n\n          doAnimate ?\n            this.$backdrop.one($.support.transition.end, callback) :\n            callback()\n\n        } else if (!this.isShown && this.$backdrop) {\n          this.$backdrop.removeClass('in')\n\n          $.support.transition && this.$element.hasClass('fade')?\n            this.$backdrop.one($.support.transition.end, callback) :\n            callback()\n\n        } else if (callback) {\n          callback()\n        }\n      }\n  }\n\n\n /* MODAL PLUGIN DEFINITION\n  * ======================= */\n\n  var old = $.fn.modal\n\n  $.fn.modal = function (option) {\n    return this.each(function () {\n      var $this = $(this)\n        , data = $this.data('modal')\n        , options = $.extend({}, $.fn.modal.defaults, $this.data(), typeof option == 'object' && option)\n      if (!data) $this.data('modal', (data = new Modal(this, options)))\n      if (typeof option == 'string') data[option]()\n      else if (options.show) data.show()\n    })\n  }\n\n  $.fn.modal.defaults = {\n      backdrop: true\n    , keyboard: true\n    , show: true\n  }\n\n  $.fn.modal.Constructor = Modal\n\n\n /* MODAL NO CONFLICT\n  * ================= */\n\n  $.fn.modal.noConflict = function () {\n    $.fn.modal = old\n    return this\n  }\n\n\n /* MODAL DATA-API\n  * ============== */\n\n  $(document).on('click.modal.data-api', '[data-toggle=\"modal\"]', function (e) {\n    var $this = $(this)\n      , href = $this.attr('href')\n      , $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\\s]+$)/, ''))) //strip for ie7\n      , option = $target.data('modal') ? 'toggle' : $.extend({ remote:!/#/.test(href) && href }, $target.data(), $this.data())\n\n    e.preventDefault()\n\n    $target\n      .modal(option)\n      .one('hide', function () {\n        $this.focus()\n      })\n  })\n\n}(window.jQuery);\n    //Plugin code goes here.\n/* ============================================================\n * bootstrap-button.js v2.3.0\n * http://twitter.github.com/bootstrap/javascript.html#buttons\n * ============================================================\n * Copyright 2012 Twitter, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ============================================================ */\n\n\n!function ($) {\n\n   // jshint ;_;\n\n\n /* BUTTON PUBLIC CLASS DEFINITION\n  * ============================== */\n\n  var Button = function (element, options) {\n    this.$element = $(element)\n    this.options = $.extend({}, $.fn.button.defaults, options)\n  }\n\n  Button.prototype.setState = function (state) {\n    var d = 'disabled'\n      , $el = this.$element\n      , data = $el.data()\n      , val = $el.is('input') ? 'val' : 'html'\n\n    state = state + 'Text'\n    data.resetText || $el.data('resetText', $el[val]())\n\n    $el[val](data[state] || this.options[state])\n\n    // push to event loop to allow forms to submit\n    setTimeout(function () {\n      state == 'loadingText' ?\n        $el.addClass(d).attr(d, d) :\n        $el.removeClass(d).removeAttr(d)\n    }, 0)\n  }\n\n  Button.prototype.toggle = function () {\n    var $parent = this.$element.closest('[data-toggle=\"buttons-radio\"]')\n\n    $parent && $parent\n      .find('.active')\n      .removeClass('active')\n\n    this.$element.toggleClass('active')\n  }\n\n\n /* BUTTON PLUGIN DEFINITION\n  * ======================== */\n\n  var old = $.fn.button\n\n  $.fn.button = function (option) {\n    return this.each(function () {\n      var $this = $(this)\n        , data = $this.data('button')\n        , options = typeof option == 'object' && option\n      if (!data) $this.data('button', (data = new Button(this, options)))\n      if (option == 'toggle') data.toggle()\n      else if (option) data.setState(option)\n    })\n  }\n\n  $.fn.button.defaults = {\n    loadingText: 'loading...'\n  }\n\n  $.fn.button.Constructor = Button\n\n\n /* BUTTON NO CONFLICT\n  * ================== */\n\n  $.fn.button.noConflict = function () {\n    $.fn.button = old\n    return this\n  }\n\n\n /* BUTTON DATA-API\n  * =============== */\n\n  $(document).on('click.button.data-api', '[data-toggle^=button]', function (e) {\n    var $btn = $(e.target)\n    if (!$btn.hasClass('btn')) $btn = $btn.closest('.btn')\n    $btn.button('toggle')\n  })\n\n}(window.jQuery);\n    //Plugin code goes here.\n/* ==========================================================\n * bootstrap-alert.js v2.3.0\n * http://twitter.github.com/bootstrap/javascript.html#alerts\n * ==========================================================\n * Copyright 2012 Twitter, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ========================================================== */\n\n\n!function ($) {\n\n   // jshint ;_;\n\n\n /* ALERT CLASS DEFINITION\n  * ====================== */\n\n  var dismiss = '[data-dismiss=\"alert\"]'\n    , Alert = function (el) {\n        $(el).on('click', dismiss, this.close)\n      }\n\n  Alert.prototype.close = function (e) {\n    var $this = $(this)\n      , selector = $this.attr('data-target')\n      , $parent\n\n    if (!selector) {\n      selector = $this.attr('href')\n      selector = selector && selector.replace(/.*(?=#[^\\s]*$)/, '') //strip for ie7\n    }\n\n    $parent = $(selector)\n\n    e && e.preventDefault()\n\n    $parent.length || ($parent = $this.hasClass('alert') ? $this : $this.parent())\n\n    $parent.trigger(e = $.Event('close'))\n\n    if (e.isDefaultPrevented()) return\n\n    $parent.removeClass('in')\n\n    function removeElement() {\n      $parent\n        .trigger('closed')\n        .remove()\n    }\n\n    $.support.transition && $parent.hasClass('fade') ?\n      $parent.on($.support.transition.end, removeElement) :\n      removeElement()\n  }\n\n\n /* ALERT PLUGIN DEFINITION\n  * ======================= */\n\n  var old = $.fn.alert\n\n  $.fn.alert = function (option) {\n    return this.each(function () {\n      var $this = $(this)\n        , data = $this.data('alert')\n      if (!data) $this.data('alert', (data = new Alert(this)))\n      if (typeof option == 'string') data[option].call($this)\n    })\n  }\n\n  $.fn.alert.Constructor = Alert\n\n\n /* ALERT NO CONFLICT\n  * ================= */\n\n  $.fn.alert.noConflict = function () {\n    $.fn.alert = old\n    return this\n  }\n\n\n /* ALERT DATA-API\n  * ============== */\n\n  $(document).on('click.alert.data-api', dismiss, Alert.prototype.close)\n\n}(window.jQuery);\n    //Plugin code goes here.\n\n/* =============================================================\n * bootstrap-typeahead.js v2.2.2\n * http://twitter.github.com/bootstrap/javascript.html#typeahead\n * =============================================================\n * Copyright 2012 Twitter, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * ============================================================ */\n\n\nreturn{\n\taddItem:'<div class=\"row-fluid itemRow\" id=\"addedItem{{index}}\"><div class=\"span7 itemName\">{{data.NAME}}</div><div class=\"span1 itemName\">{{data.PRICE}}</div><div class=\"span1\"><input id=\"itemQuantity{{index}}\" class=\"inputQuantity input-block-level\" type=\"number\" value=0></div><div class=\"span1 itemName\">{{data.UNIT}}</div><div class=\"span1 itemValue\" id=\"itemValue{{index}}\">0.00</div><div class=\"span1 itemRemove\"><a class=\"btn btn-danger\" id=\"removeItem{{index}}\"><i class=\"icon-remove-circle icon-black\"></i></a></div></div>',\n\ttypeAhead:'<input class=\"input-large\" type=\"text\" id=\"ingredientTypeahead\" placeholder=\"Start typing ingredient name\" /> <span class=\"help-inline itemName\" id=\"inputWarning\"></span>',\n\tformSuccess:'<div class=\"alert alert-block\" id=\"ingredientBoxSuccessAlert\">You can haz succesz <a class=\"close\" data-dismiss=\"alert\" id=\"ingredientBoxSuccessAlertClose\">&times;</a> </div>',\n\tformError:'<div class=\"alert alert-block alert-error\" id=\"ingredientBoxErrorAlert\">You can haz error\t<a class=\"close\" data-dismiss=\"alert\" id=\"ingredientBoxErrorAlertClose\">&times;</a></div>'\n};\n});\n/*!\n * typeahead.js 0.8.1\n * https://github.com/twitter/typeahead\n * Copyright 2013 Twitter, Inc. and other contributors; Licensed MIT\n */\ndefine('assets/js/components/typeahead/dist/typeahead',['jquery'], function($){\n\n\n\n(function() {\n    var VERSION = \"0.8.1\";\n    var utils = {\n        isMsie: function() {\n            return /msie [\\w.]+/i.test(navigator.userAgent);\n        },\n        isString: function(obj) {\n            return typeof obj === \"string\";\n        },\n        isNumber: function(obj) {\n            return typeof obj === \"number\";\n        },\n        isArray: $.isArray,\n        isFunction: $.isFunction,\n        isObject: function(obj) {\n            return obj === Object(obj);\n        },\n        isUndefined: function(obj) {\n            return typeof obj === \"undefined\";\n        },\n        bind: $.proxy,\n        bindAll: function(obj) {\n            var val;\n            for (var key in obj) {\n                utils.isFunction(val = obj[key]) && (obj[key] = $.proxy(val, obj));\n            }\n        },\n        indexOf: function(haystack, needle) {\n            for (var i = 0; i < haystack.length; i++) {\n                if (haystack[i] === needle) {\n                    return i;\n                }\n            }\n            return -1;\n        },\n        each: $.each,\n        map: $.map,\n        filter: function(obj, test) {\n            var results = [];\n            $.each(obj, function(key, val) {\n                if (test(val, key, obj)) {\n                    results.push(val);\n                }\n            });\n            return results;\n        },\n        every: function(obj, test) {\n            var result = true;\n            if (!obj) {\n                return result;\n            }\n            $.each(obj, function(key, val) {\n                if (!(result = test.call(null, val, key, obj))) {\n                    return false;\n                }\n            });\n            return !!result;\n        },\n        mixin: $.extend,\n        getUniqueId: function() {\n            var counter = 0;\n            return function() {\n                return counter++;\n            };\n        }(),\n        debounce: function(func, wait, immediate) {\n            var timeout, result;\n            return function() {\n                var context = this, args = arguments, later, callNow;\n                later = function() {\n                    timeout = null;\n                    if (!immediate) {\n                        result = func.apply(context, args);\n                    }\n                };\n                callNow = immediate && !timeout;\n                clearTimeout(timeout);\n                timeout = setTimeout(later, wait);\n                if (callNow) {\n                    result = func.apply(context, args);\n                }\n                return result;\n            };\n        },\n        throttle: function(func, wait) {\n            var context, args, timeout, result, previous, later;\n            previous = 0;\n            later = function() {\n                previous = new Date();\n                timeout = null;\n                result = func.apply(context, args);\n            };\n            return function() {\n                var now = new Date(), remaining = wait - (now - previous);\n                context = this;\n                args = arguments;\n                if (remaining <= 0) {\n                    clearTimeout(timeout);\n                    timeout = null;\n                    previous = now;\n                    result = func.apply(context, args);\n                } else if (!timeout) {\n                    timeout = setTimeout(later, remaining);\n                }\n                return result;\n            };\n        },\n        uniqueArray: function(array) {\n            var u = {}, a = [];\n            for (var i = 0, l = array.length; i < l; ++i) {\n                if (u.hasOwnProperty(array[i])) {\n                    continue;\n                }\n                a.push(array[i]);\n                u[array[i]] = 1;\n            }\n            return a;\n        },\n        tokenizeQuery: function(str) {\n            return $.trim(str).toLowerCase().split(/[\\s]+/);\n        },\n        tokenizeText: function(str) {\n            return $.trim(str).toLowerCase().split(/[\\s\\-_]+/);\n        },\n        getProtocol: function() {\n            return location.protocol;\n        },\n        noop: function() {}\n    };\n    var EventTarget = function() {\n        var eventSplitter = /\\s+/;\n        return {\n            on: function(events, callback) {\n                var event;\n                if (!callback) {\n                    return this;\n                }\n                this._callbacks = this._callbacks || {};\n                events = events.split(eventSplitter);\n                while (event = events.shift()) {\n                    this._callbacks[event] = this._callbacks[event] || [];\n                    this._callbacks[event].push(callback);\n                }\n                return this;\n            },\n            trigger: function(events, data) {\n                var event, callbacks;\n                if (!this._callbacks) {\n                    return this;\n                }\n                events = events.split(eventSplitter);\n                while (event = events.shift()) {\n                    if (callbacks = this._callbacks[event]) {\n                        for (var i = 0; i < callbacks.length; i += 1) {\n                            callbacks[i].call(this, {\n                                type: event,\n                                data: data\n                            });\n                        }\n                    }\n                }\n                return this;\n            }\n        };\n    }();\n    var PersistentStorage = function() {\n        var ls = window.localStorage, methods;\n        function PersistentStorage(namespace) {\n            this.prefix = [ \"__\", namespace, \"__\" ].join(\"\");\n            this.ttlKey = \"__ttl__\";\n            this.keyMatcher = new RegExp(\"^\" + this.prefix);\n        }\n        if (window.localStorage && window.JSON) {\n            methods = {\n                _prefix: function(key) {\n                    return this.prefix + key;\n                },\n                _ttlKey: function(key) {\n                    return this._prefix(key) + this.ttlKey;\n                },\n                get: function(key) {\n                    if (this.isExpired(key)) {\n                        this.remove(key);\n                    }\n                    return decode(ls.getItem(this._prefix(key)));\n                },\n                set: function(key, val, ttl) {\n                    if (utils.isNumber(ttl)) {\n                        ls.setItem(this._ttlKey(key), encode(now() + ttl));\n                    } else {\n                        ls.removeItem(this._ttlKey(key));\n                    }\n                    return ls.setItem(this._prefix(key), encode(val));\n                },\n                remove: function(key) {\n                    ls.removeItem(this._ttlKey(key));\n                    ls.removeItem(this._prefix(key));\n                    return this;\n                },\n                clear: function() {\n                    var i, key, keys = [], len = ls.length;\n                    for (i = 0; i < len; i++) {\n                        if ((key = ls.key(i)).match(this.keyMatcher)) {\n                            keys.push(key.replace(this.keyMatcher, \"\"));\n                        }\n                    }\n                    for (i = keys.length; i--; ) {\n                        this.remove(keys[i]);\n                    }\n                    return this;\n                },\n                isExpired: function(key) {\n                    var ttl = decode(ls.getItem(this._ttlKey(key)));\n                    return utils.isNumber(ttl) && now() > ttl ? true : false;\n                }\n            };\n        } else {\n            methods = {\n                get: utils.noop,\n                set: utils.noop,\n                remove: utils.noop,\n                clear: utils.noop,\n                isExpired: utils.noop\n            };\n        }\n        utils.mixin(PersistentStorage.prototype, methods);\n        return PersistentStorage;\n        function now() {\n            return new Date().getTime();\n        }\n        function encode(val) {\n            return JSON.stringify(utils.isUndefined(val) ? null : val);\n        }\n        function decode(val) {\n            return JSON.parse(val);\n        }\n    }();\n    var RequestCache = function() {\n        function RequestCache(o) {\n            utils.bindAll(this);\n            o = o || {};\n            this.sizeLimit = o.sizeLimit || 10;\n            this.cache = {};\n            this.cachedKeysByAge = [];\n        }\n        utils.mixin(RequestCache.prototype, {\n            get: function(url) {\n                return this.cache[url];\n            },\n            set: function(url, resp) {\n                var requestToEvict;\n                if (this.cachedKeysByAge.length === this.sizeLimit) {\n                    requestToEvict = this.cachedKeysByAge.shift();\n                    delete this.cache[requestToEvict];\n                }\n                this.cache[url] = resp;\n                this.cachedKeysByAge.push(url);\n            }\n        });\n        return RequestCache;\n    }();\n    var Transport = function() {\n        function Transport(o) {\n            var rateLimitFn;\n            utils.bindAll(this);\n            o = o || {};\n            rateLimitFn = /^throttle$/i.test(o.rateLimitFn) ? utils.throttle : utils.debounce;\n            this.wait = o.wait || 300;\n            this.wildcard = o.wildcard || \"%QUERY\";\n            this.maxConcurrentRequests = o.maxConcurrentRequests || 6;\n            this.concurrentRequests = 0;\n            this.onDeckRequestArgs = null;\n            this.cache = new RequestCache();\n            this.get = rateLimitFn(this.get, this.wait);\n        }\n        utils.mixin(Transport.prototype, {\n            _incrementConcurrentRequests: function() {\n                this.concurrentRequests++;\n            },\n            _decrementConcurrentRequests: function() {\n                this.concurrentRequests--;\n            },\n            _belowConcurrentRequestsThreshold: function() {\n                return this.concurrentRequests < this.maxConcurrentRequests;\n            },\n            get: function(url, query, cb) {\n                var that = this, resp;\n                url = url.replace(this.wildcard, encodeURIComponent(query || \"\"));\n                if (resp = this.cache.get(url)) {\n                    cb && cb(resp);\n                } else if (this._belowConcurrentRequestsThreshold()) {\n                    $.ajax({\n                        url: url,\n                        type: \"GET\",\n                        dataType: \"json\",\n                        beforeSend: function() {\n                            that._incrementConcurrentRequests();\n                        },\n                        success: function(resp) {\n                            cb && cb(resp);\n                            that.cache.set(url, resp);\n                        },\n                        complete: function() {\n                            that._decrementConcurrentRequests();\n                            if (that.onDeckRequestArgs) {\n                                that.get.apply(that, that.onDeckRequestArgs);\n                                that.onDeckRequestArgs = null;\n                            }\n                        }\n                    });\n                } else {\n                    this.onDeckRequestArgs = [].slice.call(arguments, 0);\n                }\n            }\n        });\n        return Transport;\n    }();\n    var Dataset = function() {\n        function Dataset(o) {\n            utils.bindAll(this);\n            this.storage = new PersistentStorage(o.name);\n            this.adjacencyList = {};\n            this.itemHash = {};\n            this.name = o.name;\n            this.resetDataOnProtocolSwitch = o.resetDataOnProtocolSwitch || false;\n            this.queryUrl = o.remote;\n            this.transport = o.transport;\n            this.limit = o.limit || 10;\n            this._customMatcher = o.matcher || null;\n            this._customRanker = o.ranker || null;\n            this._ttl_ms = o.ttl_ms || 3 * 24 * 60 * 60 * 1e3;\n            this.keys = {\n                version: \"version\",\n                protocol: \"protocol\",\n                itemHash: \"itemHash\",\n                adjacencyList: \"adjacencyList\"\n            };\n            o.local && this._processLocalData(o.local);\n            o.prefetch && this._loadPrefetchData(o.prefetch);\n        }\n        utils.mixin(Dataset.prototype, {\n            _processLocalData: function(data) {\n                data && this._mergeProcessedData(this._processData(data));\n            },\n            _loadPrefetchData: function(url) {\n                var that = this, itemHash = this.storage.get(this.keys.itemHash), adjacencyList = this.storage.get(this.keys.adjacencyList), protocol = this.storage.get(this.keys.protocol), version = this.storage.get(this.keys.version), isExpired = version !== VERSION || protocol !== utils.getProtocol();\n                if (itemHash && adjacencyList && !isExpired) {\n                    this._mergeProcessedData({\n                        itemHash: itemHash,\n                        adjacencyList: adjacencyList\n                    });\n                } else {\n                    $.getJSON(url).done(processPrefetchData);\n                }\n                function processPrefetchData(data) {\n                    var processedData = that._processData(data), itemHash = processedData.itemHash, adjacencyList = processedData.adjacencyList;\n                    that.storage.set(that.keys.itemHash, itemHash, that._ttl_ms);\n                    that.storage.set(that.keys.adjacencyList, adjacencyList, that._ttl_ms);\n                    that.storage.set(that.keys.version, VERSION, that._ttl_ms);\n                    that.storage.set(that.keys.protocol, utils.getProtocol(), that._ttl_ms);\n                    that._mergeProcessedData(processedData);\n                }\n            },\n            _processData: function(data) {\n                var itemHash = {}, adjacencyList = {};\n                utils.each(data, function(i, item) {\n                    var id;\n                    if (utils.isString(item)) {\n                        item = {\n                            value: item,\n                            tokens: utils.tokenizeText(item)\n                        };\n                    }\n                    item.tokens = utils.map(item.tokens || [], function(token) {\n                        return token.toLowerCase();\n                    });\n                    itemHash[id = utils.getUniqueId(item.value)] = item;\n                    utils.each(item.tokens, function(i, token) {\n                        var char = token.charAt(0), adjacency = adjacencyList[char] || (adjacencyList[char] = [ id ]);\n                        !~utils.indexOf(adjacency, id) && adjacency.push(id);\n                    });\n                });\n                return {\n                    itemHash: itemHash,\n                    adjacencyList: adjacencyList\n                };\n            },\n            _mergeProcessedData: function(processedData) {\n                var that = this;\n                utils.mixin(this.itemHash, processedData.itemHash);\n                utils.each(processedData.adjacencyList, function(char, adjacency) {\n                    var masterAdjacency = that.adjacencyList[char];\n                    that.adjacencyList[char] = masterAdjacency ? masterAdjacency.concat(adjacency) : adjacency;\n                });\n            },\n            _getPotentiallyMatchingIds: function(terms) {\n                var potentiallyMatchingIds = [];\n                var lists = [];\n                utils.map(terms, utils.bind(function(term) {\n                    var list = this.adjacencyList[term.charAt(0)];\n                    if (!list) {\n                        return;\n                    }\n                    lists.push(list);\n                }, this));\n                if (lists.length === 1) {\n                    return lists[0];\n                }\n                var listLengths = [];\n                $.each(lists, function(i, list) {\n                    listLengths.push(list.length);\n                });\n                var shortestListIndex = utils.indexOf(listLengths, Math.min.apply(null, listLengths)) || 0;\n                var shortestList = lists[shortestListIndex] || [];\n                potentiallyMatchingIds = utils.map(shortestList, function(item) {\n                    var idInEveryList = utils.every(lists, function(list) {\n                        return utils.indexOf(list, item) > -1;\n                    });\n                    if (idInEveryList) {\n                        return item;\n                    }\n                });\n                return potentiallyMatchingIds;\n            },\n            _getItemsFromIds: function(ids) {\n                var items = [];\n                utils.map(ids, utils.bind(function(id) {\n                    var item = this.itemHash[id];\n                    if (item) {\n                        items.push(item);\n                    }\n                }, this));\n                return items;\n            },\n            _matcher: function(terms) {\n                if (this._customMatcher) {\n                    var customMatcher = this._customMatcher;\n                    return function(item) {\n                        return customMatcher(item);\n                    };\n                } else {\n                    return function(item) {\n                        var tokens = item.tokens;\n                        var allTermsMatched = utils.every(terms, function(term) {\n                            var tokensMatched = utils.filter(tokens, function(token) {\n                                return token.indexOf(term) === 0;\n                            });\n                            return tokensMatched.length;\n                        });\n                        if (allTermsMatched) {\n                            return item;\n                        }\n                    };\n                }\n            },\n            _compareItems: function(a, b, areLocalItems) {\n                var aScoreBoost = !a.score_boost ? 0 : a.score_boost, bScoreBoost = !b.score_boost ? 0 : b.score_boost, aScore = !a.score ? 0 : a.score, bScore = !b.score ? 0 : b.score;\n                if (areLocalItems) {\n                    return b.weight + bScoreBoost - (a.weight + aScoreBoost);\n                } else {\n                    return bScore + bScoreBoost - (aScore + aScoreBoost);\n                }\n            },\n            _ranker: function(a, b) {\n                if (this._customRanker) {\n                    return this._customRanker(a, b);\n                } else {\n                    var aIsLocal = a.weight && a.weight !== 0;\n                    var bIsLocal = b.weight && b.weight !== 0;\n                    if (aIsLocal && !bIsLocal) {\n                        return -1;\n                    } else if (bIsLocal && !aIsLocal) {\n                        return 1;\n                    } else {\n                        return aIsLocal && bIsLocal ? this._compareItems(a, b, true) : this._compareItems(a, b, false);\n                    }\n                }\n            },\n            _processRemoteSuggestions: function(callback, matchedItems) {\n                var that = this;\n                return function(data) {\n                    utils.each(data, function(i, remoteItem) {\n                        var isDuplicate = false;\n                        remoteItem = utils.isString(remoteItem) ? {\n                            value: remoteItem\n                        } : remoteItem;\n                        utils.each(matchedItems, function(i, localItem) {\n                            if (remoteItem.value === localItem.value) {\n                                isDuplicate = true;\n                                return false;\n                            }\n                        });\n                        !isDuplicate && matchedItems.push(remoteItem);\n                        return matchedItems.length < that.limit;\n                    });\n                    callback && callback(matchedItems);\n                };\n            },\n            getSuggestions: function(query, callback) {\n                var terms = utils.tokenizeQuery(query);\n                var potentiallyMatchingIds = this._getPotentiallyMatchingIds(terms);\n                var potentiallyMatchingItems = this._getItemsFromIds(potentiallyMatchingIds);\n                var matchedItems = utils.filter(potentiallyMatchingItems, this._matcher(terms));\n                matchedItems.sort(this._ranker);\n                callback && callback(matchedItems);\n                if (matchedItems.length < this.limit && this.queryUrl) {\n                    this.transport.get(this.queryUrl, query, this._processRemoteSuggestions(callback, matchedItems));\n                }\n            }\n        });\n        return Dataset;\n    }();\n    var InputView = function() {\n        function InputView(o) {\n            var that = this;\n            utils.bindAll(this);\n            this.specialKeyCodeMap = {\n                9: \"tab\",\n                27: \"esc\",\n                37: \"left\",\n                39: \"right\",\n                13: \"enter\",\n                38: \"up\",\n                40: \"down\"\n            };\n            this.query = \"\";\n            this.$hint = $(o.hint);\n            this.$input = $(o.input).on(\"blur\", this._handleBlur).on(\"focus\", this._handleFocus).on(\"keydown\", this._handleSpecialKeyEvent);\n            if (!utils.isMsie()) {\n                this.$input.on(\"input\", this._compareQueryToInputValue);\n            } else {\n                this.$input.on(\"keydown keypress cut paste\", function(e) {\n                    if (that.specialKeyCodeMap[e.which || e.keyCode]) {\n                        return;\n                    }\n                    setTimeout(that._compareQueryToInputValue, 0);\n                });\n            }\n            this.$overflowHelper = buildOverflowHelper(this.$input);\n        }\n        utils.mixin(InputView.prototype, EventTarget, {\n            _handleFocus: function() {\n                this.trigger(\"focus\");\n            },\n            _handleBlur: function() {\n                this.trigger(\"blur\");\n            },\n            _handleSpecialKeyEvent: function($e) {\n                var keyName = this.specialKeyCodeMap[$e.which || $e.keyCode];\n                keyName && this.trigger(keyName, $e);\n            },\n            _compareQueryToInputValue: function() {\n                var inputValue = this.getInputValue(), isSameQuery = compareQueries(this.query, inputValue), isSameQueryExceptWhitespace = isSameQuery ? this.query.length !== inputValue.length : false;\n                if (isSameQueryExceptWhitespace) {\n                    this.trigger(\"whitespaceChange\", {\n                        value: this.query\n                    });\n                } else if (!isSameQuery) {\n                    this.trigger(\"queryChange\", {\n                        value: this.query = inputValue\n                    });\n                }\n            },\n            focus: function() {\n                this.$input.focus();\n            },\n            blur: function() {\n                this.$input.blur();\n            },\n            getQuery: function() {\n                return this.query;\n            },\n            getInputValue: function() {\n                return this.$input.val();\n            },\n            setInputValue: function(value, silent) {\n                this.$input.val(value);\n                if (silent !== true) {\n                    this._compareQueryToInputValue();\n                }\n            },\n            getHintValue: function() {\n                return this.$hint.val();\n            },\n            setHintValue: function(value) {\n                this.$hint.val(value);\n            },\n            getLanguageDirection: function() {\n                return (this.$input.css(\"direction\") || \"ltr\").toLowerCase();\n            },\n            isOverflow: function() {\n                this.$overflowHelper.text(this.getInputValue());\n                return this.$overflowHelper.width() > this.$input.width();\n            },\n            isCursorAtEnd: function() {\n                var valueLength = this.$input.val().length, selectionStart = this.$input[0].selectionStart, range;\n                if (utils.isNumber(selectionStart)) {\n                    return selectionStart === valueLength;\n                } else if (document.selection) {\n                    range = document.selection.createRange();\n                    range.moveStart(\"character\", -valueLength);\n                    return valueLength === range.text.length;\n                }\n                return true;\n            }\n        });\n        return InputView;\n        function buildOverflowHelper($input) {\n            return $(\"<span></span>\").css({\n                display:\"none\",\n\t\t\t\tposition: \"absolute\",\n                left: \"-9999px\",\n                visibility: \"hidden\",\n                whiteSpace: \"nowrap\",\n                fontFamily: $input.css(\"font-family\"),\n                fontSize: $input.css(\"font-size\"),\n                fontStyle: $input.css(\"font-style\"),\n                fontVariant: $input.css(\"font-variant\"),\n                fontWeight: $input.css(\"font-weight\"),\n                wordSpacing: $input.css(\"word-spacing\"),\n                letterSpacing: $input.css(\"letter-spacing\"),\n                textIndent: $input.css(\"text-indent\"),\n                textRendering: $input.css(\"text-rendering\"),\n                textTransform: $input.css(\"text-transform\")\n            }).insertAfter($input);\n        }\n        function compareQueries(a, b) {\n            a = (a || \"\").replace(/^\\s*/g, \"\").replace(/\\s{2,}/g, \" \").toLowerCase();\n            b = (b || \"\").replace(/^\\s*/g, \"\").replace(/\\s{2,}/g, \" \").toLowerCase();\n            return a === b;\n        }\n    }();\n    var DropdownView = function() {\n        function DropdownView(o) {\n            utils.bindAll(this);\n            this.isMouseOverDropdown;\n            this.$menu = $(o.menu).on(\"mouseenter\", this._handleMouseenter).on(\"mouseleave\", this._handleMouseleave).on(\"mouseover\", \".tt-suggestions > .tt-suggestion\", this._handleMouseover).on(\"click\", \".tt-suggestions > .tt-suggestion\", this._handleSelection);\n        }\n        utils.mixin(DropdownView.prototype, EventTarget, {\n            _handleMouseenter: function() {\n                this.isMouseOverDropdown = true;\n            },\n            _handleMouseleave: function() {\n                this.isMouseOverDropdown = false;\n            },\n            _handleMouseover: function($e) {\n                this._getSuggestions().removeClass(\"tt-is-under-cursor\");\n                $($e.currentTarget).addClass(\"tt-is-under-cursor\");\n            },\n            _handleSelection: function($e) {\n                this.trigger(\"select\", formatDataForSuggestion($($e.currentTarget)));\n            },\n            _moveCursor: function(increment) {\n                var $suggestions, $cur, nextIndex, $underCursor;\n                if (!this.$menu.hasClass(\"tt-is-open\")) {\n                    return;\n                }\n                $suggestions = this._getSuggestions();\n                $cur = $suggestions.filter(\".tt-is-under-cursor\");\n                $cur.removeClass(\"tt-is-under-cursor\");\n                nextIndex = $suggestions.index($cur) + increment;\n                nextIndex = (nextIndex + 1) % ($suggestions.length + 1) - 1;\n                if (nextIndex === -1) {\n                    this.trigger(\"cursorOff\");\n                    return;\n                } else if (nextIndex < -1) {\n                    nextIndex = $suggestions.length - 1;\n                }\n                $underCursor = $suggestions.eq(nextIndex).addClass(\"tt-is-under-cursor\");\n                this.trigger(\"cursorOn\", {\n                    value: $underCursor.data(\"value\")\n                });\n            },\n            _getSuggestions: function() {\n                return this.$menu.find(\".tt-suggestions > .tt-suggestion\");\n            },\n            hideUnlessMouseIsOverDropdown: function() {\n                if (!this.isMouseOverDropdown) {\n                    this.hide();\n                }\n            },\n            hide: function() {\n                if (this.$menu.hasClass(\"tt-is-open\")) {\n                    this.$menu.removeClass(\"tt-is-open\").find(\".tt-suggestions > .tt-suggestion\").removeClass(\"tt-is-under-cursor\");\n                    this.trigger(\"hide\");\n                }\n            },\n            show: function() {\n                if (!this.$menu.hasClass(\"tt-is-open\")) {\n                    this.$menu.addClass(\"tt-is-open\");\n                    this.trigger(\"show\");\n                }\n            },\n            isOpen: function() {\n                return this.$menu.hasClass(\"tt-is-open\");\n            },\n            moveCursorUp: function() {\n                this._moveCursor(-1);\n            },\n            moveCursorDown: function() {\n                this._moveCursor(+1);\n            },\n            getSuggestionUnderCursor: function() {\n                var $suggestion = this._getSuggestions().filter(\".tt-is-under-cursor\").first();\n                return $suggestion.length > 0 ? formatDataForSuggestion($suggestion) : null;\n            },\n            getFirstSuggestion: function() {\n                var $suggestion = this._getSuggestions().first();\n                return $suggestion.length > 0 ? formatDataForSuggestion($suggestion) : null;\n            },\n            renderSuggestions: function(query, dataset, suggestions) {\n                \n                var datasetClassName = \"tt-dataset-\" + dataset.name, $dataset = this.$menu.find(\".\" + datasetClassName), elBuilder, fragment, el;\n                if ($dataset.length === 0) {\n                    $dataset = $('<li><ol class=\"tt-suggestions\"></ol></li>').addClass(datasetClassName).appendTo(this.$menu);\n                }\n                elBuilder = document.createElement(\"div\");\n                fragment = document.createDocumentFragment();\n                this.clearSuggestions(dataset.name);\n                if (suggestions.length > 0) {\n                    this.$menu.removeClass(\"tt-is-empty\");\n                    utils.each(suggestions, function(i, suggestion) {\n                        elBuilder.innerHTML = dataset.template.render(suggestion);\n                        el = elBuilder.firstChild;\n                        el.setAttribute(\"data-value\", suggestion.value);\n                        fragment.appendChild(el);\n                    });\n                }\n                $dataset.find(\"> .tt-suggestions\").data({\n                    query: query,\n                    dataset: dataset.name,\n                    suggestions:suggestions\n                }).append(fragment);\n                this.trigger(\"suggestionsRender\");\n            },\n            clearSuggestions: function(datasetName) {\n                var $suggestions = datasetName ? this.$menu.find(\".tt-dataset-\" + datasetName + \" .tt-suggestions\") : this.$menu.find(\".tt-suggestions\");\n                $suggestions.empty();\n                this._getSuggestions().length === 0 && this.$menu.addClass(\"tt-is-empty\");\n            }\n        });\n        return DropdownView;\n        function formatDataForSuggestion($suggestion) {\n            var $suggestions = $suggestion.parents(\".tt-suggestions\").first();\n            return {\n                value: $suggestion.data(\"value\"),\n                query: $suggestions.data(\"query\"),\n                dataset: $suggestions.data(\"dataset\"),\n                data:$suggestions.data(\"suggestions\")\n            };\n        }\n    }();\n    var TypeaheadView = function() {\n        var html = {\n            wrapper: '<span class=\"twitter-typeahead\"></span>',\n            hint: '<input style=\"display:none;\">',\n            dropdown: '<ol class=\"tt-dropdown-menu tt-is-empty\"></ol>'\n        };\n        function TypeaheadView(o) {\n            utils.bindAll(this);\n            this.$node = wrapInput(o.input);\n            this.datasets = o.datasets;\n            utils.each(this.datasets, function(key, dataset) {\n                var parentTemplate = '<li class=\"tt-suggestion\">%body</li>';\n                if (dataset.template) {\n                    dataset.template = dataset.engine.compile(parentTemplate.replace(\"%body\", dataset.template));\n                } else {\n                    dataset.template = {\n                        render: function(context) {\n                            return parentTemplate.replace(\"%body\", \"<p>\" + context.value + \"</p>\");\n                        }\n                    };\n                }\n            });\n            this.inputView = new InputView({\n                input: this.$node.find(\".tt-query\"),\n                hint: this.$node.find(\".tt-hint\")\n            });\n            this.dropdownView = new DropdownView({\n                menu: this.$node.find(\".tt-dropdown-menu\")\n            });\n            this.dropdownView.on(\"select\", this._handleSelection).on(\"cursorOn\", this._clearHint).on(\"cursorOn\", this._setInputValueToSuggestionUnderCursor).on(\"cursorOff\", this._setInputValueToQuery).on(\"cursorOff\", this._updateHint).on(\"suggestionsRender\", this._updateHint).on(\"show\", this._updateHint).on(\"hide\", this._clearHint);\n            this.inputView.on(\"focus\", this._showDropdown).on(\"blur\", this._hideDropdown).on(\"blur\", this._setInputValueToQuery).on(\"enter\", this._handleSelection).on(\"queryChange\", this._clearHint).on(\"queryChange\", this._clearSuggestions).on(\"queryChange\", this._getSuggestions).on(\"whitespaceChange\", this._updateHint).on(\"queryChange whitespaceChange\", this._showDropdown).on(\"queryChange whitespaceChange\", this._setLanguageDirection).on(\"esc\", this._hideDropdown).on(\"esc\", this._setInputValueToQuery).on(\"tab up down\", this._managePreventDefault).on(\"up down\", this._moveDropdownCursor).on(\"up down\", this._showDropdown).on(\"tab left right\", this._autocomplete);\n        }\n        utils.mixin(TypeaheadView.prototype, EventTarget, {\n            _managePreventDefault: function(e) {\n                var $e = e.data, hint, inputValue, preventDefault = false;\n                switch (e.type) {\n                  case \"tab\":\n                    hint = this.inputView.getHintValue();\n                    inputValue = this.inputView.getInputValue();\n                    preventDefault = hint && hint !== inputValue;\n                    break;\n\n                  case \"up\":\n                  case \"down\":\n                    preventDefault = !$e.shiftKey && !$e.ctrlKey && !$e.metaKey;\n                    break;\n                }\n                preventDefault && $e.preventDefault();\n            },\n            _setLanguageDirection: function() {\n                var dirClassName = \"tt-\" + this.inputView.getLanguageDirection();\n                if (!this.$node.hasClass(dirClassName)) {\n                    this.$node.removeClass(\"tt-ltr tt-rtl\").addClass(dirClassName);\n                }\n            },\n            _updateHint: function() {\n                var dataForFirstSuggestion = this.dropdownView.getFirstSuggestion(), hint = dataForFirstSuggestion ? dataForFirstSuggestion.value : null, inputValue, query, beginsWithQuery, match;\n                if (hint && this.dropdownView.isOpen() && !this.inputView.isOverflow()) {\n                    inputValue = this.inputView.getInputValue();\n                    query = inputValue.replace(/\\s{2,}/g, \" \").replace(/^\\s+/g, \"\");\n                    beginsWithQuery = new RegExp(\"^(?:\" + query + \")(.*$)\", \"i\");\n                    match = beginsWithQuery.exec(hint);\n                    this.inputView.setHintValue(inputValue + (match ? match[1] : \"\"));\n                }\n            },\n            _clearHint: function() {\n                this.inputView.setHintValue(\"\");\n            },\n            _clearSuggestions: function() {\n                this.dropdownView.clearSuggestions();\n            },\n            _setInputValueToQuery: function() {\n                this.inputView.setInputValue(this.inputView.getQuery());\n            },\n            _setInputValueToSuggestionUnderCursor: function(e) {\n                var suggestion = e.data;\n                this.inputView.setInputValue(suggestion.value, true);\n            },\n            _showDropdown: function() {\n                this.dropdownView.show();\n            },\n            _hideDropdown: function(e) {\n                this.dropdownView[e.type === \"blur\" ? \"hideUnlessMouseIsOverDropdown\" : \"hide\"]();\n            },\n            _moveDropdownCursor: function(e) {\n                var $e = e.data;\n                if (!$e.shiftKey && !$e.ctrlKey && !$e.metaKey) {\n                    this.dropdownView[e.type === \"up\" ? \"moveCursorUp\" : \"moveCursorDown\"]();\n                }\n            },\n            _handleSelection: function(e) {\n                var byClick = e.type === \"select\", suggestionData = byClick ? e.data : this.dropdownView.getSuggestionUnderCursor();\n                if (suggestionData) {\n                    this.inputView.setInputValue(suggestionData.value);\n                    byClick ? this.inputView.focus() : e.data.preventDefault();\n                    byClick && utils.isMsie() ? setTimeout(this.dropdownView.hide, 0) : this.dropdownView.hide();\n                    //create an event here\n                    var myEvent = CustomEvent(suggestionData.data[0].callback.type, {\n                        detail: {\n                            returnData: suggestionData\n                        }\n                    });\n                    //Trigger it!\n                    document.getElementById(suggestionData.data[0].callback.target).dispatchEvent(myEvent);\n                }\n            },\n            _getSuggestions: function() {\n                var that = this, query = this.inputView.getQuery();\n                utils.each(this.datasets, function(i, dataset) {\n                    dataset.getSuggestions(query, function(suggestions) {\n                        that._renderSuggestions(query, dataset, suggestions);\n                    });\n                });\n            },\n            _renderSuggestions: function(query, dataset, suggestions) {\n                if (query !== this.inputView.getQuery()) {\n                    return;\n                }\n                suggestions = suggestions.slice(0, dataset.limit);\n                this.dropdownView.renderSuggestions(query, dataset, suggestions);\n            },\n            _autocomplete: function(e) {\n                var isCursorAtEnd, ignoreEvent, query, hint;\n                if (e.type === \"right\" || e.type === \"left\") {\n                    isCursorAtEnd = this.inputView.isCursorAtEnd();\n                    ignoreEvent = this.inputView.getLanguageDirection() === \"ltr\" ? e.type === \"left\" : e.type === \"right\";\n                    if (!isCursorAtEnd || ignoreEvent) {\n                        return;\n                    }\n                }\n                query = this.inputView.getQuery();\n                hint = this.inputView.getHintValue();\n                if (hint !== \"\" && query !== hint) {\n                    this.inputView.setInputValue(hint);\n                }\n            }\n        });\n        return TypeaheadView;\n        function wrapInput(input) {\n            var $input = $(input), $hint = $(html.hint).css({\n                \"background-color\": $input.css(\"background-color\")\n            });\n            if ($input.length === 0) {\n                return null;\n            }\n            try {\n                !$input.attr(\"dir\") && $input.attr(\"dir\", \"auto\");\n            } catch (e) {}\n            return $input.attr({\n                autocomplete: \"off\",\n                spellcheck: false\n            }).addClass(\"tt-query\").wrap(html.wrapper).parent().prepend($hint).append(html.dropdown);\n        }\n    }();\n    (function() {\n        var initializedDatasets = {}, transportOptions = {}, transport, methods;\n        jQuery.fn.typeahead = typeahead;\n        typeahead.configureTransport = configureTransport;\n\t\tmethods = {\n            initialize: function(datasetDefs) {\n                var datasets = {};\n                datasetDefs = utils.isArray(datasetDefs) ? datasetDefs : [ datasetDefs ];\n                if (datasetDefs.length === 0) {\n                    throw new Error(\"no datasets provided\");\n                }\n                delete typeahead.configureTransport;\n                transport = transport || new Transport(transportOptions);\n                utils.each(datasetDefs, function(i, datasetDef) {\n                    var dataset, name = datasetDef.name = datasetDef.name || utils.getUniqueId();\n                    if (initializedDatasets[name]) {\n                        dataset = initializedDatasets[name];\n                    } else {\n                        datasetDef.limit = datasetDef.limit || 5;\n                        datasetDef.template = datasetDef.template;\n                        datasetDef.engine = datasetDef.engine;\n                        if (datasetDef.template && !datasetDef.engine) {\n                            throw new Error(\"no template engine specified for \" + name);\n                        }\n                        dataset = initializedDatasets[name] = new Dataset({\n                            name: datasetDef.name,\n                            limit: datasetDef.limit,\n                            local: datasetDef.local,\n                            prefetch: datasetDef.prefetch,\n                            ttl_ms: datasetDef.ttl_ms,\n                            remote: datasetDef.remote,\n                            matcher: datasetDef.matcher,\n                            ranker: datasetDef.ranker,\n                            transport: transport\n                        });\n                    }\n                    datasets[name] = {\n                        name: datasetDef.name,\n                        limit: datasetDef.limit,\n                        template: datasetDef.template,\n                        engine: datasetDef.engine,\n                        getSuggestions: dataset.getSuggestions\n                    };\n                });\n                return this.each(function() {\n                    $(this).data({\n                        typeahead: new TypeaheadView({\n                            input: this,\n                            datasets: datasets\n                        })\n                    });\n                });\n            }\n        };\n        function typeahead(method) {\n            if (methods[method]) {\n                return methods[method].apply(this, [].slice.call(arguments, 1));\n            } else {\n                return methods.initialize.apply(this, arguments);\n            }\n        }\n        function configureTransport(o) {\n            transportOptions = o;\n        }\n    })();\n})();\n});\n/*!\n * mustache.js - Logic-less {{mustache}} templates with JavaScript\n * http://github.com/janl/mustache.js\n */\n\n/*global define: false*/\n\n(function (root, factory) {\n  if (typeof exports === \"object\" && exports) {\n    module.exports = factory; // CommonJS\n  } else if (typeof define === \"function\" && define.amd) {\n    define('mustache',factory); // AMD\n  } else {\n    root.Mustache = factory; // <script>\n  }\n}(this, (function () {\n\n  var exports = {};\n\n  exports.name = \"mustache.js\";\n  exports.version = \"0.7.2\";\n  exports.tags = [\"{{\", \"}}\"];\n\n  exports.Scanner = Scanner;\n  exports.Context = Context;\n  exports.Writer = Writer;\n\n  var whiteRe = /\\s*/;\n  var spaceRe = /\\s+/;\n  var nonSpaceRe = /\\S/;\n  var eqRe = /\\s*=/;\n  var curlyRe = /\\s*\\}/;\n  var tagRe = /#|\\^|\\/|>|\\{|&|=|!/;\n\n  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577\n  // See https://github.com/janl/mustache.js/issues/189\n  function testRe(re, string) {\n    return RegExp.prototype.test.call(re, string);\n  }\n\n  function isWhitespace(string) {\n    return !testRe(nonSpaceRe, string);\n  }\n\n  var isArray = Array.isArray || function (obj) {\n    return Object.prototype.toString.call(obj) === \"[object Array]\";\n  };\n\n  function escapeRe(string) {\n    return string.replace(/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]/g, \"\\\\$&\");\n  }\n\n  var entityMap = {\n    \"&\": \"&amp;\",\n    \"<\": \"&lt;\",\n    \">\": \"&gt;\",\n    '\"': '&quot;',\n    \"'\": '&#39;',\n    \"/\": '&#x2F;'\n  };\n\n  function escapeHtml(string) {\n    return String(string).replace(/[&<>\"'\\/]/g, function (s) {\n      return entityMap[s];\n    });\n  }\n\n  // Export the escaping function so that the user may override it.\n  // See https://github.com/janl/mustache.js/issues/244\n  exports.escape = escapeHtml;\n\n  function Scanner(string) {\n    this.string = string;\n    this.tail = string;\n    this.pos = 0;\n  }\n\n  /**\n   * Returns `true` if the tail is empty (end of string).\n   */\n  Scanner.prototype.eos = function () {\n    return this.tail === \"\";\n  };\n\n  /**\n   * Tries to match the given regular expression at the current position.\n   * Returns the matched text if it can match, the empty string otherwise.\n   */\n  Scanner.prototype.scan = function (re) {\n    var match = this.tail.match(re);\n\n    if (match && match.index === 0) {\n      this.tail = this.tail.substring(match[0].length);\n      this.pos += match[0].length;\n      return match[0];\n    }\n\n    return \"\";\n  };\n\n  /**\n   * Skips all text until the given regular expression can be matched. Returns\n   * the skipped string, which is the entire tail if no match can be made.\n   */\n  Scanner.prototype.scanUntil = function (re) {\n    var match, pos = this.tail.search(re);\n\n    switch (pos) {\n    case -1:\n      match = this.tail;\n      this.pos += this.tail.length;\n      this.tail = \"\";\n      break;\n    case 0:\n      match = \"\";\n      break;\n    default:\n      match = this.tail.substring(0, pos);\n      this.tail = this.tail.substring(pos);\n      this.pos += pos;\n    }\n\n    return match;\n  };\n\n  function Context(view, parent) {\n    this.view = view;\n    this.parent = parent;\n    this.clearCache();\n  }\n\n  Context.make = function (view) {\n    return (view instanceof Context) ? view : new Context(view);\n  };\n\n  Context.prototype.clearCache = function () {\n    this._cache = {};\n  };\n\n  Context.prototype.push = function (view) {\n    return new Context(view, this);\n  };\n\n  Context.prototype.lookup = function (name) {\n    var value = this._cache[name];\n\n    if (!value) {\n      if (name === \".\") {\n        value = this.view;\n      } else {\n        var context = this;\n\n        while (context) {\n          if (name.indexOf(\".\") > 0) {\n            var names = name.split(\".\"), i = 0;\n\n            value = context.view;\n\n            while (value && i < names.length) {\n              value = value[names[i++]];\n            }\n          } else {\n            value = context.view[name];\n          }\n\n          if (value != null) {\n            break;\n          }\n\n          context = context.parent;\n        }\n      }\n\n      this._cache[name] = value;\n    }\n\n    if (typeof value === \"function\") {\n      value = value.call(this.view);\n    }\n\n    return value;\n  };\n\n  function Writer() {\n    this.clearCache();\n  }\n\n  Writer.prototype.clearCache = function () {\n    this._cache = {};\n    this._partialCache = {};\n  };\n\n  Writer.prototype.compile = function (template, tags) {\n    var fn = this._cache[template];\n\n    if (!fn) {\n      var tokens = exports.parse(template, tags);\n      fn = this._cache[template] = this.compileTokens(tokens, template);\n    }\n\n    return fn;\n  };\n\n  Writer.prototype.compilePartial = function (name, template, tags) {\n    var fn = this.compile(template, tags);\n    this._partialCache[name] = fn;\n    return fn;\n  };\n\n  Writer.prototype.compileTokens = function (tokens, template) {\n    var fn = compileTokens(tokens);\n    var self = this;\n\n    return function (view, partials) {\n      if (partials) {\n        if (typeof partials === \"function\") {\n          self._loadPartial = partials;\n        } else {\n          for (var name in partials) {\n            self.compilePartial(name, partials[name]);\n          }\n        }\n      }\n\n      return fn(self, Context.make(view), template);\n    };\n  };\n\n  Writer.prototype.render = function (template, view, partials) {\n    return this.compile(template)(view, partials);\n  };\n\n  Writer.prototype._section = function (name, context, text, callback) {\n    var value = context.lookup(name);\n\n    switch (typeof value) {\n    case \"object\":\n      if (isArray(value)) {\n        var buffer = \"\";\n\n        for (var i = 0, len = value.length; i < len; ++i) {\n          buffer += callback(this, context.push(value[i]));\n        }\n\n        return buffer;\n      }\n\n      return value ? callback(this, context.push(value)) : \"\";\n    case \"function\":\n      var self = this;\n      var scopedRender = function (template) {\n        return self.render(template, context);\n      };\n\n      var result = value.call(context.view, text, scopedRender);\n      return result != null ? result : \"\";\n    default:\n      if (value) {\n        return callback(this, context);\n      }\n    }\n\n    return \"\";\n  };\n\n  Writer.prototype._inverted = function (name, context, callback) {\n    var value = context.lookup(name);\n\n    // Use JavaScript's definition of falsy. Include empty arrays.\n    // See https://github.com/janl/mustache.js/issues/186\n    if (!value || (isArray(value) && value.length === 0)) {\n      return callback(this, context);\n    }\n\n    return \"\";\n  };\n\n  Writer.prototype._partial = function (name, context) {\n    if (!(name in this._partialCache) && this._loadPartial) {\n      this.compilePartial(name, this._loadPartial(name));\n    }\n\n    var fn = this._partialCache[name];\n\n    return fn ? fn(context) : \"\";\n  };\n\n  Writer.prototype._name = function (name, context) {\n    var value = context.lookup(name);\n\n    if (typeof value === \"function\") {\n      value = value.call(context.view);\n    }\n\n    return (value == null) ? \"\" : String(value);\n  };\n\n  Writer.prototype._escaped = function (name, context) {\n    return exports.escape(this._name(name, context));\n  };\n\n  /**\n   * Low-level function that compiles the given `tokens` into a function\n   * that accepts three arguments: a Writer, a Context, and the template.\n   */\n  function compileTokens(tokens) {\n    var subRenders = {};\n\n    function subRender(i, tokens, template) {\n      if (!subRenders[i]) {\n        var fn = compileTokens(tokens);\n        subRenders[i] = function (writer, context) {\n          return fn(writer, context, template);\n        };\n      }\n\n      return subRenders[i];\n    }\n\n    return function (writer, context, template) {\n      var buffer = \"\";\n      var token, sectionText;\n\n      for (var i = 0, len = tokens.length; i < len; ++i) {\n        token = tokens[i];\n\n        switch (token[0]) {\n        case \"#\":\n          sectionText = template.slice(token[3], token[5]);\n          buffer += writer._section(token[1], context, sectionText, subRender(i, token[4], template));\n          break;\n        case \"^\":\n          buffer += writer._inverted(token[1], context, subRender(i, token[4], template));\n          break;\n        case \">\":\n          buffer += writer._partial(token[1], context);\n          break;\n        case \"&\":\n          buffer += writer._name(token[1], context);\n          break;\n        case \"name\":\n          buffer += writer._escaped(token[1], context);\n          break;\n        case \"text\":\n          buffer += token[1];\n          break;\n        }\n      }\n\n      return buffer;\n    };\n  }\n\n  /**\n   * Forms the given array of `tokens` into a nested tree structure where\n   * tokens that represent a section have two additional items: 1) an array of\n   * all tokens that appear in that section and 2) the index in the original\n   * template that represents the end of that section.\n   */\n  function nestTokens(tokens) {\n    var tree = [];\n    var collector = tree;\n    var sections = [];\n\n    var token;\n    for (var i = 0, len = tokens.length; i < len; ++i) {\n      token = tokens[i];\n      switch (token[0]) {\n      case '#':\n      case '^':\n        sections.push(token);\n        collector.push(token);\n        collector = token[4] = [];\n        break;\n      case '/':\n        var section = sections.pop();\n        section[5] = token[2];\n        collector = sections.length > 0 ? sections[sections.length - 1][4] : tree;\n        break;\n      default:\n        collector.push(token);\n      }\n    }\n\n    return tree;\n  }\n\n  /**\n   * Combines the values of consecutive text tokens in the given `tokens` array\n   * to a single token.\n   */\n  function squashTokens(tokens) {\n    var squashedTokens = [];\n\n    var token, lastToken;\n    for (var i = 0, len = tokens.length; i < len; ++i) {\n      token = tokens[i];\n      if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {\n        lastToken[1] += token[1];\n        lastToken[3] = token[3];\n      } else {\n        lastToken = token;\n        squashedTokens.push(token);\n      }\n    }\n\n    return squashedTokens;\n  }\n\n  function escapeTags(tags) {\n    return [\n      new RegExp(escapeRe(tags[0]) + \"\\\\s*\"),\n      new RegExp(\"\\\\s*\" + escapeRe(tags[1]))\n    ];\n  }\n\n  /**\n   * Breaks up the given `template` string into a tree of token objects. If\n   * `tags` is given here it must be an array with two string values: the\n   * opening and closing tags used in the template (e.g. [\"<%\", \"%>\"]). Of\n   * course, the default is to use mustaches (i.e. Mustache.tags).\n   */\n  exports.parse = function (template, tags) {\n    template = template || '';\n    tags = tags || exports.tags;\n\n    if (typeof tags === 'string') tags = tags.split(spaceRe);\n    if (tags.length !== 2) {\n      throw new Error('Invalid tags: ' + tags.join(', '));\n    }\n\n    var tagRes = escapeTags(tags);\n    var scanner = new Scanner(template);\n\n    var sections = [];     // Stack to hold section tokens\n    var tokens = [];       // Buffer to hold the tokens\n    var spaces = [];       // Indices of whitespace tokens on the current line\n    var hasTag = false;    // Is there a {{tag}} on the current line?\n    var nonSpace = false;  // Is there a non-space char on the current line?\n\n    // Strips all whitespace tokens array for the current line\n    // if there was a {{#tag}} on it and otherwise only space.\n    function stripSpace() {\n      if (hasTag && !nonSpace) {\n        while (spaces.length) {\n          tokens.splice(spaces.pop(), 1);\n        }\n      } else {\n        spaces = [];\n      }\n\n      hasTag = false;\n      nonSpace = false;\n    }\n\n    var start, type, value, chr;\n    while (!scanner.eos()) {\n      start = scanner.pos;\n      value = scanner.scanUntil(tagRes[0]);\n\n      if (value) {\n        for (var i = 0, len = value.length; i < len; ++i) {\n          chr = value.charAt(i);\n\n          if (isWhitespace(chr)) {\n            spaces.push(tokens.length);\n          } else {\n            nonSpace = true;\n          }\n\n          tokens.push([\"text\", chr, start, start + 1]);\n          start += 1;\n\n          if (chr === \"\\n\") {\n            stripSpace(); // Check for whitespace on the current line.\n          }\n        }\n      }\n\n      start = scanner.pos;\n\n      // Match the opening tag.\n      if (!scanner.scan(tagRes[0])) {\n        break;\n      }\n\n      hasTag = true;\n      type = scanner.scan(tagRe) || \"name\";\n\n      // Skip any whitespace between tag and value.\n      scanner.scan(whiteRe);\n\n      // Extract the tag value.\n      if (type === \"=\") {\n        value = scanner.scanUntil(eqRe);\n        scanner.scan(eqRe);\n        scanner.scanUntil(tagRes[1]);\n      } else if (type === \"{\") {\n        var closeRe = new RegExp(\"\\\\s*\" + escapeRe(\"}\" + tags[1]));\n        value = scanner.scanUntil(closeRe);\n        scanner.scan(curlyRe);\n        scanner.scanUntil(tagRes[1]);\n        type = \"&\";\n      } else {\n        value = scanner.scanUntil(tagRes[1]);\n      }\n\n      // Match the closing tag.\n      if (!scanner.scan(tagRes[1])) {\n        throw new Error('Unclosed tag at ' + scanner.pos);\n      }\n\n      // Check section nesting.\n      if (type === '/') {\n        if (sections.length === 0) {\n          throw new Error('Unopened section \"' + value + '\" at ' + start);\n        }\n\n        var section = sections.pop();\n\n        if (section[1] !== value) {\n          throw new Error('Unclosed section \"' + section[1] + '\" at ' + start);\n        }\n      }\n\n      var token = [type, value, start, scanner.pos];\n      tokens.push(token);\n\n      if (type === '#' || type === '^') {\n        sections.push(token);\n      } else if (type === \"name\" || type === \"{\" || type === \"&\") {\n        nonSpace = true;\n      } else if (type === \"=\") {\n        // Set the tags for the next time around.\n        tags = value.split(spaceRe);\n\n        if (tags.length !== 2) {\n          throw new Error('Invalid tags at ' + start + ': ' + tags.join(', '));\n        }\n\n        tagRes = escapeTags(tags);\n      }\n    }\n\n    // Make sure there are no open sections when we're done.\n    var section = sections.pop();\n    if (section) {\n      throw new Error('Unclosed section \"' + section[1] + '\" at ' + scanner.pos);\n    }\n\n    return nestTokens(squashTokens(tokens));\n  };\n\n  // The high-level clearCache, compile, compilePartial, and render functions\n  // use this default writer.\n  var _writer = new Writer();\n\n  /**\n   * Clears all cached templates and partials in the default writer.\n   */\n  exports.clearCache = function () {\n    return _writer.clearCache();\n  };\n\n  /**\n   * Compiles the given `template` to a reusable function using the default\n   * writer.\n   */\n  exports.compile = function (template, tags) {\n    return _writer.compile(template, tags);\n  };\n\n  /**\n   * Compiles the partial with the given `name` and `template` to a reusable\n   * function using the default writer.\n   */\n  exports.compilePartial = function (name, template, tags) {\n    return _writer.compilePartial(name, template, tags);\n  };\n\n  /**\n   * Compiles the given array of tokens (the output of a parse) to a reusable\n   * function using the default writer.\n   */\n  exports.compileTokens = function (tokens, template) {\n    return _writer.compileTokens(tokens, template);\n  };\n\n  /**\n   * Renders the `template` with the given `view` and `partials` using the\n   * default writer.\n   */\n  exports.render = function (template, view, partials) {\n    return _writer.render(template, view, partials);\n  };\n\n  // This is here for backwards compatibility with 0.4.x.\n  exports.to_html = function (template, view, partials, send) {\n    var result = exports.render(template, view, partials);\n\n    if (typeof send === \"function\") {\n      send(result);\n    } else {\n      return result;\n    }\n  };\n\n  return exports;\n\n}())));\n\n//     Underscore.js 1.4.4\n//     http://underscorejs.org\n//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore may be freely distributed under the MIT license.\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var push             = ArrayProto.push,\n      slice            = ArrayProto.slice,\n      concat           = ArrayProto.concat,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) {\n    if (obj instanceof _) return obj;\n    if (!(this instanceof _)) return new _(obj);\n    this._wrapped = obj;\n  };\n\n  // Export the Underscore object for **Node.js**, with\n  // backwards-compatibility for the old `require()` API. If we're in\n  // the browser, add `_` as a global object via a string identifier,\n  // for Closure Compiler \"advanced\" mode.\n  if (typeof exports !== 'undefined') {\n    if (typeof module !== 'undefined' && module.exports) {\n      exports = module.exports = _;\n    }\n    exports._ = _;\n  } else {\n    root._ = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.4.4';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (_.has(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = _.collect = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  var reduceError = 'Reduce of empty array with no initial value';\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    var initial = arguments.length > 2;\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var length = obj.length;\n    if (length !== +length) {\n      var keys = _.keys(obj);\n      length = keys.length;\n    }\n    each(obj, function(value, index, list) {\n      index = keys ? keys[--length] : --length;\n      if (!initial) {\n        memo = obj[index];\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, obj[index], index, list);\n      }\n    });\n    if (!initial) throw new TypeError(reduceError);\n    return memo;\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    return _.filter(obj, function(value, index, list) {\n      return !iterator.call(context, value, index, list);\n    }, context);\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator || (iterator = _.identity);\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result || (result = iterator.call(context, value, index, list))) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if the array or object contains a given value (using `===`).\n  // Aliased as `include`.\n  _.contains = _.include = function(obj, target) {\n    if (obj == null) return false;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    return any(obj, function(value) {\n      return value === target;\n    });\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    var isFunc = _.isFunction(method);\n    return _.map(obj, function(value) {\n      return (isFunc ? method : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Convenience version of a common use case of `filter`: selecting only objects\n  // containing specific `key:value` pairs.\n  _.where = function(obj, attrs, first) {\n    if (_.isEmpty(attrs)) return first ? null : [];\n    return _[first ? 'find' : 'filter'](obj, function(value) {\n      for (var key in attrs) {\n        if (attrs[key] !== value[key]) return false;\n      }\n      return true;\n    });\n  };\n\n  // Convenience version of a common use case of `find`: getting the first object\n  // containing specific `key:value` pairs.\n  _.findWhere = function(obj, attrs) {\n    return _.where(obj, attrs, true);\n  };\n\n  // Return the maximum element or (element-based computation).\n  // Can't optimize arrays of integers longer than 65,535 elements.\n  // See: https://bugs.webkit.org/show_bug.cgi?id=80797\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.max.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return -Infinity;\n    var result = {computed : -Infinity, value: -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {\n      return Math.min.apply(Math, obj);\n    }\n    if (!iterator && _.isEmpty(obj)) return Infinity;\n    var result = {computed : Infinity, value: Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Shuffle an array.\n  _.shuffle = function(obj) {\n    var rand;\n    var index = 0;\n    var shuffled = [];\n    each(obj, function(value) {\n      rand = _.random(index++);\n      shuffled[index - 1] = shuffled[rand];\n      shuffled[rand] = value;\n    });\n    return shuffled;\n  };\n\n  // An internal function to generate lookup iterators.\n  var lookupIterator = function(value) {\n    return _.isFunction(value) ? value : function(obj){ return obj[value]; };\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, value, context) {\n    var iterator = lookupIterator(value);\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        index : index,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria;\n      var b = right.criteria;\n      if (a !== b) {\n        if (a > b || a === void 0) return 1;\n        if (a < b || b === void 0) return -1;\n      }\n      return left.index < right.index ? -1 : 1;\n    }), 'value');\n  };\n\n  // An internal function used for aggregate \"group by\" operations.\n  var group = function(obj, value, context, behavior) {\n    var result = {};\n    var iterator = lookupIterator(value || _.identity);\n    each(obj, function(value, index) {\n      var key = iterator.call(context, value, index, obj);\n      behavior(result, key, value);\n    });\n    return result;\n  };\n\n  // Groups the object's values by a criterion. Pass either a string attribute\n  // to group by, or a function that returns the criterion.\n  _.groupBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key, value) {\n      (_.has(result, key) ? result[key] : (result[key] = [])).push(value);\n    });\n  };\n\n  // Counts instances of an object that group by a certain criterion. Pass\n  // either a string attribute to count by, or a function that returns the\n  // criterion.\n  _.countBy = function(obj, value, context) {\n    return group(obj, value, context, function(result, key) {\n      if (!_.has(result, key)) result[key] = 0;\n      result[key]++;\n    });\n  };\n\n  // Use a comparator function to figure out the smallest index at which\n  // an object should be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator, context) {\n    iterator = iterator == null ? _.identity : lookupIterator(iterator);\n    var value = iterator.call(context, obj);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >>> 1;\n      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(obj) {\n    if (!obj) return [];\n    if (_.isArray(obj)) return slice.call(obj);\n    if (obj.length === +obj.length) return _.map(obj, _.identity);\n    return _.values(obj);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    if (obj == null) return 0;\n    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head` and `take`. The **guard** check\n  // allows it to work with `_.map`.\n  _.first = _.head = _.take = function(array, n, guard) {\n    if (array == null) return void 0;\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the last entry of the array. Especially useful on\n  // the arguments object. Passing **n** will return all the values in\n  // the array, excluding the last N. The **guard** check allows it to work with\n  // `_.map`.\n  _.initial = function(array, n, guard) {\n    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));\n  };\n\n  // Get the last element of an array. Passing **n** will return the last N\n  // values in the array. The **guard** check allows it to work with `_.map`.\n  _.last = function(array, n, guard) {\n    if (array == null) return void 0;\n    if ((n != null) && !guard) {\n      return slice.call(array, Math.max(array.length - n, 0));\n    } else {\n      return array[array.length - 1];\n    }\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.\n  // Especially useful on the arguments object. Passing an **n** will return\n  // the rest N values in the array. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = _.drop = function(array, n, guard) {\n    return slice.call(array, (n == null) || guard ? 1 : n);\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, _.identity);\n  };\n\n  // Internal implementation of a recursive `flatten` function.\n  var flatten = function(input, shallow, output) {\n    each(input, function(value) {\n      if (_.isArray(value)) {\n        shallow ? push.apply(output, value) : flatten(value, shallow, output);\n      } else {\n        output.push(value);\n      }\n    });\n    return output;\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array, shallow) {\n    return flatten(array, shallow, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted, iterator, context) {\n    if (_.isFunction(isSorted)) {\n      context = iterator;\n      iterator = isSorted;\n      isSorted = false;\n    }\n    var initial = iterator ? _.map(array, iterator, context) : array;\n    var results = [];\n    var seen = [];\n    each(initial, function(value, index) {\n      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {\n        seen.push(value);\n        results.push(array[index]);\n      }\n    });\n    return results;\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(concat.apply(ArrayProto, arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays.\n  _.intersection = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and a number of other arrays.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array) {\n    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));\n    return _.filter(array, function(value){ return !_.contains(rest, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) {\n      results[i] = _.pluck(args, \"\" + i);\n    }\n    return results;\n  };\n\n  // Converts lists into objects. Pass either a single array of `[key, value]`\n  // pairs, or two parallel arrays of the same length -- one of keys, and one of\n  // the corresponding values.\n  _.object = function(list, values) {\n    if (list == null) return {};\n    var result = {};\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (values) {\n        result[list[i]] = values[i];\n      } else {\n        result[list[i][0]] = list[i][1];\n      }\n    }\n    return result;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i = 0, l = array.length;\n    if (isSorted) {\n      if (typeof isSorted == 'number') {\n        i = (isSorted < 0 ? Math.max(0, l + isSorted) : isSorted);\n      } else {\n        i = _.sortedIndex(array, item);\n        return array[i] === item ? i : -1;\n      }\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);\n    for (; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item, from) {\n    if (array == null) return -1;\n    var hasIndex = from != null;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {\n      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);\n    }\n    var i = (hasIndex ? from : array.length);\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if\n  // available.\n  _.bind = function(func, context) {\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    var args = slice.call(arguments, 2);\n    return function() {\n      return func.apply(context, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Partially apply a function by creating a version that has had some of its\n  // arguments pre-filled, without changing its dynamic `this` context.\n  _.partial = function(func) {\n    var args = slice.call(arguments, 1);\n    return function() {\n      return func.apply(this, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length === 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(null, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    var context, args, timeout, result;\n    var previous = 0;\n    var later = function() {\n      previous = new Date;\n      timeout = null;\n      result = func.apply(context, args);\n    };\n    return function() {\n      var now = new Date;\n      var remaining = wait - (now - previous);\n      context = this;\n      args = arguments;\n      if (remaining <= 0) {\n        clearTimeout(timeout);\n        timeout = null;\n        previous = now;\n        result = func.apply(context, args);\n      } else if (!timeout) {\n        timeout = setTimeout(later, remaining);\n      }\n      return result;\n    };\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds. If `immediate` is passed, trigger the function on the\n  // leading edge, instead of the trailing.\n  _.debounce = function(func, wait, immediate) {\n    var timeout, result;\n    return function() {\n      var context = this, args = arguments;\n      var later = function() {\n        timeout = null;\n        if (!immediate) result = func.apply(context, args);\n      };\n      var callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) result = func.apply(context, args);\n      return result;\n    };\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      memo = func.apply(this, arguments);\n      func = null;\n      return memo;\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func];\n      push.apply(args, arguments);\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = arguments;\n    return function() {\n      var args = arguments;\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    if (times <= 0) return func();\n    return function() {\n      if (--times < 1) {\n        return func.apply(this, arguments);\n      }\n    };\n  };\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    var values = [];\n    for (var key in obj) if (_.has(obj, key)) values.push(obj[key]);\n    return values;\n  };\n\n  // Convert an object into a list of `[key, value]` pairs.\n  _.pairs = function(obj) {\n    var pairs = [];\n    for (var key in obj) if (_.has(obj, key)) pairs.push([key, obj[key]]);\n    return pairs;\n  };\n\n  // Invert the keys and values of an object. The values must be serializable.\n  _.invert = function(obj) {\n    var result = {};\n    for (var key in obj) if (_.has(obj, key)) result[obj[key]] = key;\n    return result;\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Return a copy of the object only containing the whitelisted properties.\n  _.pick = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    each(keys, function(key) {\n      if (key in obj) copy[key] = obj[key];\n    });\n    return copy;\n  };\n\n   // Return a copy of the object without the blacklisted properties.\n  _.omit = function(obj) {\n    var copy = {};\n    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));\n    for (var key in obj) {\n      if (!_.contains(keys, key)) copy[key] = obj[key];\n    }\n    return copy;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      if (source) {\n        for (var prop in source) {\n          if (obj[prop] == null) obj[prop] = source[prop];\n        }\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    if (!_.isObject(obj)) return obj;\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Internal recursive comparison function for `isEqual`.\n  var eq = function(a, b, aStack, bStack) {\n    // Identical objects are equal. `0 === -0`, but they aren't identical.\n    // See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.\n    if (a === b) return a !== 0 || 1 / a == 1 / b;\n    // A strict comparison is necessary because `null == undefined`.\n    if (a == null || b == null) return a === b;\n    // Unwrap any wrapped objects.\n    if (a instanceof _) a = a._wrapped;\n    if (b instanceof _) b = b._wrapped;\n    // Compare `[[Class]]` names.\n    var className = toString.call(a);\n    if (className != toString.call(b)) return false;\n    switch (className) {\n      // Strings, numbers, dates, and booleans are compared by value.\n      case '[object String]':\n        // Primitives and their corresponding object wrappers are equivalent; thus, `\"5\"` is\n        // equivalent to `new String(\"5\")`.\n        return a == String(b);\n      case '[object Number]':\n        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for\n        // other numeric values.\n        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);\n      case '[object Date]':\n      case '[object Boolean]':\n        // Coerce dates and booleans to numeric primitive values. Dates are compared by their\n        // millisecond representations. Note that invalid dates with millisecond representations\n        // of `NaN` are not equivalent.\n        return +a == +b;\n      // RegExps are compared by their source patterns and flags.\n      case '[object RegExp]':\n        return a.source == b.source &&\n               a.global == b.global &&\n               a.multiline == b.multiline &&\n               a.ignoreCase == b.ignoreCase;\n    }\n    if (typeof a != 'object' || typeof b != 'object') return false;\n    // Assume equality for cyclic structures. The algorithm for detecting cyclic\n    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.\n    var length = aStack.length;\n    while (length--) {\n      // Linear search. Performance is inversely proportional to the number of\n      // unique nested structures.\n      if (aStack[length] == a) return bStack[length] == b;\n    }\n    // Add the first object to the stack of traversed objects.\n    aStack.push(a);\n    bStack.push(b);\n    var size = 0, result = true;\n    // Recursively compare objects and arrays.\n    if (className == '[object Array]') {\n      // Compare array lengths to determine if a deep comparison is necessary.\n      size = a.length;\n      result = size == b.length;\n      if (result) {\n        // Deep compare the contents, ignoring non-numeric properties.\n        while (size--) {\n          if (!(result = eq(a[size], b[size], aStack, bStack))) break;\n        }\n      }\n    } else {\n      // Objects with different constructors are not equivalent, but `Object`s\n      // from different frames are.\n      var aCtor = a.constructor, bCtor = b.constructor;\n      if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&\n                               _.isFunction(bCtor) && (bCtor instanceof bCtor))) {\n        return false;\n      }\n      // Deep compare objects.\n      for (var key in a) {\n        if (_.has(a, key)) {\n          // Count the expected number of properties.\n          size++;\n          // Deep compare each member.\n          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;\n        }\n      }\n      // Ensure that both objects contain the same number of properties.\n      if (result) {\n        for (key in b) {\n          if (_.has(b, key) && !(size--)) break;\n        }\n        result = !size;\n      }\n    }\n    // Remove the first object from the stack of traversed objects.\n    aStack.pop();\n    bStack.pop();\n    return result;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    return eq(a, b, [], []);\n  };\n\n  // Is a given array, string, or object empty?\n  // An \"empty\" object has no enumerable own-properties.\n  _.isEmpty = function(obj) {\n    if (obj == null) return true;\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (_.has(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType === 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) == '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.\n  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {\n    _['is' + name] = function(obj) {\n      return toString.call(obj) == '[object ' + name + ']';\n    };\n  });\n\n  // Define a fallback version of the method in browsers (ahem, IE), where\n  // there isn't any inspectable \"Arguments\" type.\n  if (!_.isArguments(arguments)) {\n    _.isArguments = function(obj) {\n      return !!(obj && _.has(obj, 'callee'));\n    };\n  }\n\n  // Optimize `isFunction` if appropriate.\n  if (typeof (/./) !== 'function') {\n    _.isFunction = function(obj) {\n      return typeof obj === 'function';\n    };\n  }\n\n  // Is a given object a finite number?\n  _.isFinite = function(obj) {\n    return isFinite(obj) && !isNaN(parseFloat(obj));\n  };\n\n  // Is the given value `NaN`? (NaN is the only number which does not equal itself).\n  _.isNaN = function(obj) {\n    return _.isNumber(obj) && obj != +obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Shortcut function for checking if an object has a given property directly\n  // on itself (in other words, not on a prototype).\n  _.has = function(obj, key) {\n    return hasOwnProperty.call(obj, key);\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function(n, iterator, context) {\n    var accum = Array(n);\n    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);\n    return accum;\n  };\n\n  // Return a random integer between min and max (inclusive).\n  _.random = function(min, max) {\n    if (max == null) {\n      max = min;\n      min = 0;\n    }\n    return min + Math.floor(Math.random() * (max - min + 1));\n  };\n\n  // List of HTML entities for escaping.\n  var entityMap = {\n    escape: {\n      '&': '&amp;',\n      '<': '&lt;',\n      '>': '&gt;',\n      '\"': '&quot;',\n      \"'\": '&#x27;',\n      '/': '&#x2F;'\n    }\n  };\n  entityMap.unescape = _.invert(entityMap.escape);\n\n  // Regexes containing the keys and values listed immediately above.\n  var entityRegexes = {\n    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),\n    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')\n  };\n\n  // Functions for escaping and unescaping strings to/from HTML interpolation.\n  _.each(['escape', 'unescape'], function(method) {\n    _[method] = function(string) {\n      if (string == null) return '';\n      return ('' + string).replace(entityRegexes[method], function(match) {\n        return entityMap[method][match];\n      });\n    };\n  });\n\n  // If the value of the named property is a function then invoke it;\n  // otherwise, return it.\n  _.result = function(object, property) {\n    if (object == null) return null;\n    var value = object[property];\n    return _.isFunction(value) ? value.call(object) : value;\n  };\n\n  // Add your own custom functions to the Underscore object.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      var func = _[name] = obj[name];\n      _.prototype[name] = function() {\n        var args = [this._wrapped];\n        push.apply(args, arguments);\n        return result.call(this, func.apply(_, args));\n      };\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = ++idCounter + '';\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g,\n    escape      : /<%-([\\s\\S]+?)%>/g\n  };\n\n  // When customizing `templateSettings`, if you don't want to define an\n  // interpolation, evaluation or escaping regex, we need one that is\n  // guaranteed not to match.\n  var noMatch = /(.)^/;\n\n  // Certain characters need to be escaped so that they can be put into a\n  // string literal.\n  var escapes = {\n    \"'\":      \"'\",\n    '\\\\':     '\\\\',\n    '\\r':     'r',\n    '\\n':     'n',\n    '\\t':     't',\n    '\\u2028': 'u2028',\n    '\\u2029': 'u2029'\n  };\n\n  var escaper = /\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(text, data, settings) {\n    var render;\n    settings = _.defaults({}, settings, _.templateSettings);\n\n    // Combine delimiters into one regular expression via alternation.\n    var matcher = new RegExp([\n      (settings.escape || noMatch).source,\n      (settings.interpolate || noMatch).source,\n      (settings.evaluate || noMatch).source\n    ].join('|') + '|$', 'g');\n\n    // Compile the template source, escaping string literals appropriately.\n    var index = 0;\n    var source = \"__p+='\";\n    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {\n      source += text.slice(index, offset)\n        .replace(escaper, function(match) { return '\\\\' + escapes[match]; });\n\n      if (escape) {\n        source += \"'+\\n((__t=(\" + escape + \"))==null?'':_.escape(__t))+\\n'\";\n      }\n      if (interpolate) {\n        source += \"'+\\n((__t=(\" + interpolate + \"))==null?'':__t)+\\n'\";\n      }\n      if (evaluate) {\n        source += \"';\\n\" + evaluate + \"\\n__p+='\";\n      }\n      index = offset + match.length;\n      return match;\n    });\n    source += \"';\\n\";\n\n    // If a variable is not specified, place data values in local scope.\n    if (!settings.variable) source = 'with(obj||{}){\\n' + source + '}\\n';\n\n    source = \"var __t,__p='',__j=Array.prototype.join,\" +\n      \"print=function(){__p+=__j.call(arguments,'');};\\n\" +\n      source + \"return __p;\\n\";\n\n    try {\n      render = new Function(settings.variable || 'obj', '_', source);\n    } catch (e) {\n      e.source = source;\n      throw e;\n    }\n\n    if (data) return render(data, _);\n    var template = function(data) {\n      return render.call(this, data, _);\n    };\n\n    // Provide the compiled function source as a convenience for precompilation.\n    template.source = 'function(' + (settings.variable || 'obj') + '){\\n' + source + '}';\n\n    return template;\n  };\n\n  // Add a \"chain\" function, which will delegate to the wrapper.\n  _.chain = function(obj) {\n    return _(obj).chain();\n  };\n\n  // OOP\n  // ---------------\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj) {\n    return this._chain ? _(obj).chain() : obj;\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      var obj = this._wrapped;\n      method.apply(obj, arguments);\n      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];\n      return result.call(this, obj);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    _.prototype[name] = function() {\n      return result.call(this, method.apply(this._wrapped, arguments));\n    };\n  });\n\n  _.extend(_.prototype, {\n\n    // Start chaining a wrapped Underscore object.\n    chain: function() {\n      this._chain = true;\n      return this;\n    },\n\n    // Extracts the result from a wrapped and chained object.\n    value: function() {\n      return this._wrapped;\n    }\n\n  });\n\n  // AMD define happens at the end for compatibility with AMD loaders\n  // that don't enforce next-turn semantics on modules.\n  if (typeof define === 'function' && define.amd) {\n    define('underscore',[], function() {\n      return _;\n    });\n  }\n\n}).call(this);\n\ndefine('src/modules/Ingredients/JqueryCalls',[\n\t'jquery',\n\t'assets/js/components/bootstrap/js/bootstrap-combined',\n\t'assets/js/components/typeahead/dist/typeahead',\n\t'mustache',\n\t'underscore',\n    ],function($,Combined,Typeahead,Mustache,_){\n\tvar FormInit = function()\n\t{\n\t\t$(\"#addNewIngredientFormModal\").modal({show:false,keyboard:false});\n\t\t$(\"#addNewIngredientButton\").click(function(){\n\t\t\t$('#addNewIngredientFormModal').modal('show');\n\t\t});\n\t\t$(\"#addIngredientFormSubmit\").click(function(){\n\t\t\t$(\"#formComponent\").trigger({type:\"addFormSubmit\"});\n\t\t\t$(\"#addIngredientFormSubmit\").button(\"loading\");\n\t\t\t$(\"#addIngredientModalClose\").button(\"loading\");\n\t\t\t$(\"#addIngredientFormClear\").button(\"loading\");\n\t\t});\n        $(\"#calculatorComponent\").trigger({type:\"nextDependencyLoaded\"});     \n\t};\n\tvar FormSubmitForm = function()\n\t{\n\t\tvar formData = $(\"#addIngredientmodalForm\").serialize();\n\t\tvar cachebang = new Date().getTime();\n\t\tformData+=\"&CACHEBANG=\"+cachebang;\n\t\t$.ajax({\n\t\t\ttype:\"GET\",\n\t\t\turl:\"api/addIngredient\",\n\t\t\tdata:formData,\n\t\t\tsuccess:function(data){\n\t\t\t\t$(\"#formComponent\").trigger({\n\t\t\t\t  type:\"dataReceived\",\n\t\t\t\t  returnData:data\n\t\t\t\t});\n\t\t\t},\n\t\t\terror:function(data){console.log(\"Error in request\")}\n\t\t});\n\t};\n\tvar FormSetTimeStamp = function(event)\n\t{\n\t\t$(\"#formTimeStamp\").val(event.timestamp);\n\t};\n\t\n\tvar FormReceiveFormData = function(event)\n\t{\n\t\t\n\t\tif(!(event.returnData.init))\n\t\t{\n\t\t\tconsole.log(event);\n\t\t\t$(\"#calculatorComponent\").trigger({\n\t\t\t\ttype:\"dataReceived\",\n\t\t\t\treturnData:event.returnData\n\t\t\t});\n\t\t\t$(\"#addIngredientFormSubmit\").button(\"reset\");\n\t\t\t$(\"#addIngredientModalClose\").button(\"reset\");\n\t\t\t$(\"#addIngredientFormClear\").button(\"reset\");\n\t\t\tif(event.returnData.addedStatus.success)\n\t\t\t{\n\t\t\t\t$(\"#formAlertArea\").html(Mustache.render(Combined.formSuccess));\n\t\t\t\t$(\"#ingredientBoxSuccessAlert\").alert();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$(\"#formAlertArea\").html(Mustache.render(Combined.formError));\n\t\t\t\t$(\"#ingredientBoxErrorAlert\").alert();\n\t\t\t}\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\t\n\t\t}\n\t};\n\tvar CalculatorsetTypeAhead = function()\n\t{\n\t\t$(\"#ingredientTypeahead\").remove();\n        $(\"#inputWarning\").remove();\n        $(\"#inputControls\").html(Mustache.render(Combined.typeAhead,{}));\n        $(\"#ingredientTypeahead\").typeahead(\n        {\n            prefetch:\"api/typeaheadHackInit\"\n            //moar stuff to be added here\n        });\n\t};\n\tvar CalculatoraddItem = function(data,index)\n\t{\n\t\tconsole.log(data);\n\t\tvar id = \"addedItem\" + index;\n\t\t$(\"#itemList\").append(Mustache.render(Combined.addItem,{data:data,index:index}));\t\t\n\t\t$(\"#removeItem\" + index).click(function() {\n\t\t\t$(\"#calculatorComponent\").trigger({\n\t\t\t\ttype: \"itemRemoved\",\n\t\t\t\tindex: index\n\t\t\t});\n\t\t});\n\t\t$(\"#itemQuantity\" + index).on(\"input\", function() {\n\t\t\t$(\"#calculatorComponent\").trigger({\n\t\t\t\ttype: \"quantitiesChanged\",\n\t\t\t\tindex: index,\n\t\t\t\tremoved: false\n\t\t\t});\n\t\t});\n\t\t\n\t};\n\tvar CalculatoraddItemError = function()\n\t{\n\t\t$(\"#warningGroup\").addClass(\"error\");\n\t\t$(\"#inputWarning\").html(\"This item is already present\");\n\t};\n\tvar CalculatorremoveItem = function(index)\n\t{\n\t\t$(\"#addedItem\" + index).remove();\n\t\t$(\"#calculatorComponent\").trigger({\n                type: \"quantitiesChanged\",\n                index: index,\n                removed: true\n            });\n\t};\n\tvar CalculatorgetQuantityValues = function()\n\t{\n\t\tvar dom = $(\".inputQuantity\");\n\t\treturn (_.map(dom, function(item) {\n\t\t\tif (isNaN(parseFloat(item.value))) return 0;\n\t\t\telse if (parseFloat(item.value) < 0) return 0;\n\t\t\telse return parseFloat(item.value);\n\t\t}));\n\t\t\t\n\t};\n\tvar CalculatorrenderTotalCost = function(cost)\n\t{\n\t\tconsole.log(cost);\n\t\t$(\"#totalPriceValue\").html(cost.toFixed(2));\n\t};\n\tvar CalculatorrenderTotalCostChange = function(index,price)\n\t{\n\t\tvar thisVal = parseFloat($(\"#itemQuantity\" + index)[0].value);\n\t\tif (thisVal < 0 || isNaN(thisVal)) thisVal = 0;\n\t\tvar cost = thisVal * price;\n\t\t$(\"#itemValue\" + index).html(cost.toFixed(2));\n\t};\n\t\n\treturn{\n\t\tFormInit:FormInit,\n\t\tFormSubmitForm:FormSubmitForm,\n\t\tFormReceiveFormData:FormReceiveFormData,\n\t\tFormSetTimeStamp:FormSetTimeStamp,\n\t\tCalculatorsetTypeAhead:CalculatorsetTypeAhead,\n\t\tCalculatoraddItem:CalculatoraddItem,\n\t\tCalculatoraddItemError:CalculatoraddItemError,\n\t\tCalculatorremoveItem:CalculatorremoveItem,\n\t\tCalculatorgetQuantityValues:CalculatorgetQuantityValues,\n\t\tCalculatorrenderTotalCost:CalculatorrenderTotalCost,\n\t\tCalculatorrenderTotalCostChange:CalculatorrenderTotalCostChange\n\t\t};\n});\n//Lots of surgery needed here\ndefine('src/modules/Ingredients/Calculator',\n\t[\n\t\t'assets/js/components/flight/lib/component', \n\t\t'src/modules/Ingredients/JqueryCalls',\n        'underscore'\n\t],\n\nfunction(\n    component, \n    jQueryCalls,\n    _\n    ){\n    function Ingredients() {\n        this.defaultAttrs({\n            selectedItems: [],\n            quantities: []\n        });\n\t\tthis.Init = function()\n\t\t{\n\t\t\tthis.attr.selectedItems = [];\n\t\t\tthis.attr.quantities=[];\n\t\t};\n        this.addData = function(event)\n        {\n            var detail = event.originalEvent.detail.returnData;\n            var data = detail.data;\n            var value = detail.value;\n            var values = _.pluck(data,'value');\n            var index = values.indexOf(value);\n            if(index!=-1)\n            {\n                var UID = data[index].uid;\n                var UIDs = _.pluck(this.attr.selectedItems,'uid');\n                if(_.contains(UIDs,UID))\n                {\n                    console.log(\"Value found!\");\n                    \n                }\n                else\n                {\n                    this.attr.selectedItems.push(data[index]);\n                    console.log(data[index],\"pushed\");\n                }\n            }   \n            /*var UID = data.uid;\n            var UIDs = _.pluck(this.attr.selectedItems,'uid');\n            console.log(UIDs,UID);\n            if(_.contains(UIDs,UID))\n            {\n                console.log(\"Value found!\");\n                \n            }\n            else\n            {\n                this.attr.selectedItems.push(data);\n                console.log(data,\"pushed\");\n            }*/\n            //If Data is already present, send fail; else send data to selectedItems\n        };\n        this.after(\"initialize\", function() {\n\t\t\tthis.Init();\n\t\t\tthis.on(\"nextDependencyLoaded\",jQueryCalls.CalculatorsetTypeAhead);\n            this.on(\"dataAdded\",this.addData);\n        });\n    }\n\treturn {calculatorComponent:component(Ingredients)};\n\n});\n"]],"start1":0,"start2":0,"length1":0,"length2":150344}]],"length":150344}

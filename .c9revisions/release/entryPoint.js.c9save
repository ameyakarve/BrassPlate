{"ts":1361963982317,"silentsave":true,"restoring":false,"patch":[[{"diffs":[[1,"\n// Copyright 2009-2012 by contributors, MIT License\n// vim: ts=4 sts=4 sw=4 expandtab\n\n// Module systems magic dance\n(function (definition) {\n    // RequireJS\n    if (typeof define == \"function\") {\n        define('shim',definition);\n    // YUI3\n    } else if (typeof YUI == \"function\") {\n        YUI.add(\"es5\", definition);\n    // CommonJS and <script>\n    } else {\n        definition();\n    }\n})(function () {\n\n/**\n * Brings an environment as close to ECMAScript 5 compliance\n * as is possible with the facilities of erstwhile engines.\n *\n * Annotated ES5: http://es5.github.com/ (specific links below)\n * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf\n * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/\n */\n\n//\n// Function\n// ========\n//\n\n// ES-5 15.3.4.5\n// http://es5.github.com/#x15.3.4.5\n\nif (!Function.prototype.bind) {\n    Function.prototype.bind = function bind(that) { // .length is 1\n        // 1. Let Target be the this value.\n        var target = this;\n        // 2. If IsCallable(Target) is false, throw a TypeError exception.\n        if (typeof target != \"function\") {\n            throw new TypeError(\"Function.prototype.bind called on incompatible \" + target);\n        }\n        // 3. Let A be a new (possibly empty) internal list of all of the\n        //   argument values provided after thisArg (arg1, arg2 etc), in order.\n        // XXX slicedArgs will stand in for \"A\" if used\n        var args = slice.call(arguments, 1); // for normal call\n        // 4. Let F be a new native ECMAScript object.\n        // 11. Set the [[Prototype]] internal property of F to the standard\n        //   built-in Function prototype object as specified in 15.3.3.1.\n        // 12. Set the [[Call]] internal property of F as described in\n        //   15.3.4.5.1.\n        // 13. Set the [[Construct]] internal property of F as described in\n        //   15.3.4.5.2.\n        // 14. Set the [[HasInstance]] internal property of F as described in\n        //   15.3.4.5.3.\n        var bound = function () {\n\n            if (this instanceof bound) {\n                // 15.3.4.5.2 [[Construct]]\n                // When the [[Construct]] internal method of a function object,\n                // F that was created using the bind function is called with a\n                // list of arguments ExtraArgs, the following steps are taken:\n                // 1. Let target be the value of F's [[TargetFunction]]\n                //   internal property.\n                // 2. If target has no [[Construct]] internal method, a\n                //   TypeError exception is thrown.\n                // 3. Let boundArgs be the value of F's [[BoundArgs]] internal\n                //   property.\n                // 4. Let args be a new list containing the same values as the\n                //   list boundArgs in the same order followed by the same\n                //   values as the list ExtraArgs in the same order.\n                // 5. Return the result of calling the [[Construct]] internal\n                //   method of target providing args as the arguments.\n\n                var F = function(){};\n                F.prototype = target.prototype;\n                var self = new F;\n\n                var result = target.apply(\n                    self,\n                    args.concat(slice.call(arguments))\n                );\n                if (Object(result) === result) {\n                    return result;\n                }\n                return self;\n\n            } else {\n                // 15.3.4.5.1 [[Call]]\n                // When the [[Call]] internal method of a function object, F,\n                // which was created using the bind function is called with a\n                // this value and a list of arguments ExtraArgs, the following\n                // steps are taken:\n                // 1. Let boundArgs be the value of F's [[BoundArgs]] internal\n                //   property.\n                // 2. Let boundThis be the value of F's [[BoundThis]] internal\n                //   property.\n                // 3. Let target be the value of F's [[TargetFunction]] internal\n                //   property.\n                // 4. Let args be a new list containing the same values as the\n                //   list boundArgs in the same order followed by the same\n                //   values as the list ExtraArgs in the same order.\n                // 5. Return the result of calling the [[Call]] internal method\n                //   of target providing boundThis as the this value and\n                //   providing args as the arguments.\n\n                // equiv: target.call(this, ...boundArgs, ...args)\n                return target.apply(\n                    that,\n                    args.concat(slice.call(arguments))\n                );\n\n            }\n\n        };\n        // XXX bound.length is never writable, so don't even try\n        //\n        // 15. If the [[Class]] internal property of Target is \"Function\", then\n        //     a. Let L be the length property of Target minus the length of A.\n        //     b. Set the length own property of F to either 0 or L, whichever is\n        //       larger.\n        // 16. Else set the length own property of F to 0.\n        // 17. Set the attributes of the length own property of F to the values\n        //   specified in 15.3.5.1.\n\n        // TODO\n        // 18. Set the [[Extensible]] internal property of F to true.\n\n        // TODO\n        // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).\n        // 20. Call the [[DefineOwnProperty]] internal method of F with\n        //   arguments \"caller\", PropertyDescriptor {[[Get]]: thrower, [[Set]]:\n        //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and\n        //   false.\n        // 21. Call the [[DefineOwnProperty]] internal method of F with\n        //   arguments \"arguments\", PropertyDescriptor {[[Get]]: thrower,\n        //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},\n        //   and false.\n\n        // TODO\n        // NOTE Function objects created using Function.prototype.bind do not\n        // have a prototype property or the [[Code]], [[FormalParameters]], and\n        // [[Scope]] internal properties.\n        // XXX can't delete prototype in pure-js.\n\n        // 22. Return F.\n        return bound;\n    };\n}\n\n// Shortcut to an often accessed properties, in order to avoid multiple\n// dereference that costs universally.\n// _Please note: Shortcuts are defined after `Function.prototype.bind` as we\n// us it in defining shortcuts.\nvar call = Function.prototype.call;\nvar prototypeOfArray = Array.prototype;\nvar prototypeOfObject = Object.prototype;\nvar slice = prototypeOfArray.slice;\n// Having a toString local variable name breaks in Opera so use _toString.\nvar _toString = call.bind(prototypeOfObject.toString);\nvar owns = call.bind(prototypeOfObject.hasOwnProperty);\n\n// If JS engine supports accessors creating shortcuts.\nvar defineGetter;\nvar defineSetter;\nvar lookupGetter;\nvar lookupSetter;\nvar supportsAccessors;\nif ((supportsAccessors = owns(prototypeOfObject, \"__defineGetter__\"))) {\n    defineGetter = call.bind(prototypeOfObject.__defineGetter__);\n    defineSetter = call.bind(prototypeOfObject.__defineSetter__);\n    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);\n    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);\n}\n\n//\n// Array\n// =====\n//\n\n// ES5 15.4.3.2\n// http://es5.github.com/#x15.4.3.2\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray\nif (!Array.isArray) {\n    Array.isArray = function isArray(obj) {\n        return _toString(obj) == \"[object Array]\";\n    };\n}\n\n// The IsCallable() check in the Array functions\n// has been replaced with a strict check on the\n// internal class of the object to trap cases where\n// the provided function was actually a regular\n// expression literal, which in V8 and\n// JavaScriptCore is a typeof \"function\".  Only in\n// V8 are regular expression literals permitted as\n// reduce parameters, so it is desirable in the\n// general case for the shim to match the more\n// strict and common behavior of rejecting regular\n// expressions.\n\n// ES5 15.4.4.18\n// http://es5.github.com/#x15.4.4.18\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach\nif (!Array.prototype.forEach) {\n    Array.prototype.forEach = function forEach(fun /*, thisp*/) {\n        var self = toObject(this),\n            thisp = arguments[1],\n            i = -1,\n            length = self.length >>> 0;\n\n        // If no callback function or if callback is not a callable function\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(); // TODO message\n        }\n\n        while (++i < length) {\n            if (i in self) {\n                // Invoke the callback function with call, passing arguments:\n                // context, property value, property key, thisArg object context\n                fun.call(thisp, self[i], i, self);\n            }\n        }\n    };\n}\n\n// ES5 15.4.4.19\n// http://es5.github.com/#x15.4.4.19\n// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map\nif (!Array.prototype.map) {\n    Array.prototype.map = function map(fun /*, thisp*/) {\n        var self = toObject(this),\n            length = self.length >>> 0,\n            result = Array(length),\n            thisp = arguments[1];\n\n        // If no callback function or if callback is not a callable function\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (i in self)\n                result[i] = fun.call(thisp, self[i], i, self);\n        }\n        return result;\n    };\n}\n\n// ES5 15.4.4.20\n// http://es5.github.com/#x15.4.4.20\n// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter\nif (!Array.prototype.filter) {\n    Array.prototype.filter = function filter(fun /*, thisp */) {\n        var self = toObject(this),\n            length = self.length >>> 0,\n            result = [],\n            value,\n            thisp = arguments[1];\n\n        // If no callback function or if callback is not a callable function\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (i in self) {\n                value = self[i];\n                if (fun.call(thisp, value, i, self)) {\n                    result.push(value);\n                }\n            }\n        }\n        return result;\n    };\n}\n\n// ES5 15.4.4.16\n// http://es5.github.com/#x15.4.4.16\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every\nif (!Array.prototype.every) {\n    Array.prototype.every = function every(fun /*, thisp */) {\n        var self = toObject(this),\n            length = self.length >>> 0,\n            thisp = arguments[1];\n\n        // If no callback function or if callback is not a callable function\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (i in self && !fun.call(thisp, self[i], i, self)) {\n                return false;\n            }\n        }\n        return true;\n    };\n}\n\n// ES5 15.4.4.17\n// http://es5.github.com/#x15.4.4.17\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some\nif (!Array.prototype.some) {\n    Array.prototype.some = function some(fun /*, thisp */) {\n        var self = toObject(this),\n            length = self.length >>> 0,\n            thisp = arguments[1];\n\n        // If no callback function or if callback is not a callable function\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        for (var i = 0; i < length; i++) {\n            if (i in self && fun.call(thisp, self[i], i, self)) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\n\n// ES5 15.4.4.21\n// http://es5.github.com/#x15.4.4.21\n// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce\nif (!Array.prototype.reduce) {\n    Array.prototype.reduce = function reduce(fun /*, initial*/) {\n        var self = toObject(this),\n            length = self.length >>> 0;\n\n        // If no callback function or if callback is not a callable function\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        // no value to return if no initial value and an empty array\n        if (!length && arguments.length == 1) {\n            throw new TypeError('reduce of empty array with no initial value');\n        }\n\n        var i = 0;\n        var result;\n        if (arguments.length >= 2) {\n            result = arguments[1];\n        } else {\n            do {\n                if (i in self) {\n                    result = self[i++];\n                    break;\n                }\n\n                // if array contains no values, no initial value to return\n                if (++i >= length) {\n                    throw new TypeError('reduce of empty array with no initial value');\n                }\n            } while (true);\n        }\n\n        for (; i < length; i++) {\n            if (i in self) {\n                result = fun.call(void 0, result, self[i], i, self);\n            }\n        }\n\n        return result;\n    };\n}\n\n// ES5 15.4.4.22\n// http://es5.github.com/#x15.4.4.22\n// https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight\nif (!Array.prototype.reduceRight) {\n    Array.prototype.reduceRight = function reduceRight(fun /*, initial*/) {\n        var self = toObject(this),\n            length = self.length >>> 0;\n\n        // If no callback function or if callback is not a callable function\n        if (_toString(fun) != \"[object Function]\") {\n            throw new TypeError(fun + \" is not a function\");\n        }\n\n        // no value to return if no initial value, empty array\n        if (!length && arguments.length == 1) {\n            throw new TypeError('reduceRight of empty array with no initial value');\n        }\n\n        var result, i = length - 1;\n        if (arguments.length >= 2) {\n            result = arguments[1];\n        } else {\n            do {\n                if (i in self) {\n                    result = self[i--];\n                    break;\n                }\n\n                // if array contains no values, no initial value to return\n                if (--i < 0) {\n                    throw new TypeError('reduceRight of empty array with no initial value');\n                }\n            } while (true);\n        }\n\n        do {\n            if (i in this) {\n                result = fun.call(void 0, result, self[i], i, self);\n            }\n        } while (i--);\n\n        return result;\n    };\n}\n\n// ES5 15.4.4.14\n// http://es5.github.com/#x15.4.4.14\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf\nif (!Array.prototype.indexOf) {\n    Array.prototype.indexOf = function indexOf(sought /*, fromIndex */ ) {\n        var self = toObject(this),\n            length = self.length >>> 0;\n\n        if (!length) {\n            return -1;\n        }\n\n        var i = 0;\n        if (arguments.length > 1) {\n            i = toInteger(arguments[1]);\n        }\n\n        // handle negative indices\n        i = i >= 0 ? i : Math.max(0, length + i);\n        for (; i < length; i++) {\n            if (i in self && self[i] === sought) {\n                return i;\n            }\n        }\n        return -1;\n    };\n}\n\n// ES5 15.4.4.15\n// http://es5.github.com/#x15.4.4.15\n// https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf\nif (!Array.prototype.lastIndexOf) {\n    Array.prototype.lastIndexOf = function lastIndexOf(sought /*, fromIndex */) {\n        var self = toObject(this),\n            length = self.length >>> 0;\n\n        if (!length) {\n            return -1;\n        }\n        var i = length - 1;\n        if (arguments.length > 1) {\n            i = Math.min(i, toInteger(arguments[1]));\n        }\n        // handle negative indices\n        i = i >= 0 ? i : length - Math.abs(i);\n        for (; i >= 0; i--) {\n            if (i in self && sought === self[i]) {\n                return i;\n            }\n        }\n        return -1;\n    };\n}\n\n//\n// Object\n// ======\n//\n\n// ES5 15.2.3.14\n// http://es5.github.com/#x15.2.3.14\nif (!Object.keys) {\n    // http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation\n    var hasDontEnumBug = true,\n        dontEnums = [\n            \"toString\",\n            \"toLocaleString\",\n            \"valueOf\",\n            \"hasOwnProperty\",\n            \"isPrototypeOf\",\n            \"propertyIsEnumerable\",\n            \"constructor\"\n        ],\n        dontEnumsLength = dontEnums.length;\n\n    for (var key in {\"toString\": null}) {\n        hasDontEnumBug = false;\n    }\n\n    Object.keys = function keys(object) {\n\n        if ((typeof object != \"object\" && typeof object != \"function\") || object === null) {\n            throw new TypeError(\"Object.keys called on a non-object\");\n        }\n\n        var keys = [];\n        for (var name in object) {\n            if (owns(object, name)) {\n                keys.push(name);\n            }\n        }\n\n        if (hasDontEnumBug) {\n            for (var i = 0, ii = dontEnumsLength; i < ii; i++) {\n                var dontEnum = dontEnums[i];\n                if (owns(object, dontEnum)) {\n                    keys.push(dontEnum);\n                }\n            }\n        }\n        return keys;\n    };\n\n}\n\n//\n// Date\n// ====\n//\n\n// ES5 15.9.5.43\n// http://es5.github.com/#x15.9.5.43\n// This function returns a String value represent the instance in time\n// represented by this Date object. The format of the String is the Date Time\n// string format defined in 15.9.1.15. All fields are present in the String.\n// The time zone is always UTC, denoted by the suffix Z. If the time value of\n// this object is not a finite Number a RangeError exception is thrown.\nif (!Date.prototype.toISOString || (new Date(-62198755200000).toISOString().indexOf('-000001') === -1)) {\n    Date.prototype.toISOString = function toISOString() {\n        var result, length, value, year;\n        if (!isFinite(this)) {\n            throw new RangeError(\"Date.prototype.toISOString called on non-finite value.\");\n        }\n\n        // the date time string format is specified in 15.9.1.15.\n        result = [this.getUTCMonth() + 1, this.getUTCDate(),\n            this.getUTCHours(), this.getUTCMinutes(), this.getUTCSeconds()];\n        year = this.getUTCFullYear();\n        year = (year < 0 ? '-' : (year > 9999 ? '+' : '')) + ('00000' + Math.abs(year)).slice(0 <= year && year <= 9999 ? -4 : -6);\n\n        length = result.length;\n        while (length--) {\n            value = result[length];\n            // pad months, days, hours, minutes, and seconds to have two digits.\n            if (value < 10) {\n                result[length] = \"0\" + value;\n            }\n        }\n        // pad milliseconds to have three digits.\n        return year + \"-\" + result.slice(0, 2).join(\"-\") + \"T\" + result.slice(2).join(\":\") + \".\" +\n            (\"000\" + this.getUTCMilliseconds()).slice(-3) + \"Z\";\n    }\n}\n\n// ES5 15.9.4.4\n// http://es5.github.com/#x15.9.4.4\nif (!Date.now) {\n    Date.now = function now() {\n        return new Date().getTime();\n    };\n}\n\n// ES5 15.9.5.44\n// http://es5.github.com/#x15.9.5.44\n// This function provides a String representation of a Date object for use by\n// JSON.stringify (15.12.3).\nif (!Date.prototype.toJSON) {\n    Date.prototype.toJSON = function toJSON(key) {\n        // When the toJSON method is called with argument key, the following\n        // steps are taken:\n\n        // 1.  Let O be the result of calling ToObject, giving it the this\n        // value as its argument.\n        // 2. Let tv be ToPrimitive(O, hint Number).\n        // 3. If tv is a Number and is not finite, return null.\n        // XXX\n        // 4. Let toISO be the result of calling the [[Get]] internal method of\n        // O with argument \"toISOString\".\n        // 5. If IsCallable(toISO) is false, throw a TypeError exception.\n        if (typeof this.toISOString != \"function\") {\n            throw new TypeError('toISOString property is not callable');\n        }\n        // 6. Return the result of calling the [[Call]] internal method of\n        //  toISO with O as the this value and an empty argument list.\n        return this.toISOString();\n\n        // NOTE 1 The argument is ignored.\n\n        // NOTE 2 The toJSON function is intentionally generic; it does not\n        // require that its this value be a Date object. Therefore, it can be\n        // transferred to other kinds of objects for use as a method. However,\n        // it does require that any such object have a toISOString method. An\n        // object is free to use the argument key to filter its\n        // stringification.\n    };\n}\n\n// ES5 15.9.4.2\n// http://es5.github.com/#x15.9.4.2\n// based on work shared by Daniel Friesen (dantman)\n// http://gist.github.com/303249\nif (!Date.parse || Date.parse(\"+275760-09-13T00:00:00.000Z\") !== 8.64e15) {\n    // XXX global assignment won't work in embeddings that use\n    // an alternate object for the context.\n    Date = (function(NativeDate) {\n\n        // Date.length === 7\n        var Date = function Date(Y, M, D, h, m, s, ms) {\n            var length = arguments.length;\n            if (this instanceof NativeDate) {\n                var date = length == 1 && String(Y) === Y ? // isString(Y)\n                    // We explicitly pass it through parse:\n                    new NativeDate(Date.parse(Y)) :\n                    // We have to manually make calls depending on argument\n                    // length here\n                    length >= 7 ? new NativeDate(Y, M, D, h, m, s, ms) :\n                    length >= 6 ? new NativeDate(Y, M, D, h, m, s) :\n                    length >= 5 ? new NativeDate(Y, M, D, h, m) :\n                    length >= 4 ? new NativeDate(Y, M, D, h) :\n                    length >= 3 ? new NativeDate(Y, M, D) :\n                    length >= 2 ? new NativeDate(Y, M) :\n                    length >= 1 ? new NativeDate(Y) :\n                                  new NativeDate();\n                // Prevent mixups with unfixed Date object\n                date.constructor = Date;\n                return date;\n            }\n            return NativeDate.apply(this, arguments);\n        };\n\n        // 15.9.1.15 Date Time String Format.\n        var isoDateExpression = new RegExp(\"^\" +\n            \"(\\\\d{4}|[\\+\\-]\\\\d{6})\" + // four-digit year capture or sign + 6-digit extended year\n            \"(?:-(\\\\d{2})\" + // optional month capture\n            \"(?:-(\\\\d{2})\" + // optional day capture\n            \"(?:\" + // capture hours:minutes:seconds.milliseconds\n                \"T(\\\\d{2})\" + // hours capture\n                \":(\\\\d{2})\" + // minutes capture\n                \"(?:\" + // optional :seconds.milliseconds\n                    \":(\\\\d{2})\" + // seconds capture\n                    \"(?:\\\\.(\\\\d{3}))?\" + // milliseconds capture\n                \")?\" +\n            \"(?:\" + // capture UTC offset component\n                \"Z|\" + // UTC capture\n                \"(?:\" + // offset specifier +/-hours:minutes\n                    \"([-+])\" + // sign capture\n                    \"(\\\\d{2})\" + // hours offset capture\n                    \":(\\\\d{2})\" + // minutes offset capture\n                \")\" +\n            \")?)?)?)?\" +\n        \"$\");\n\n        // Copy any custom methods a 3rd party library may have added\n        for (var key in NativeDate) {\n            Date[key] = NativeDate[key];\n        }\n\n        // Copy \"native\" methods explicitly; they may be non-enumerable\n        Date.now = NativeDate.now;\n        Date.UTC = NativeDate.UTC;\n        Date.prototype = NativeDate.prototype;\n        Date.prototype.constructor = Date;\n\n        // Upgrade Date.parse to handle simplified ISO 8601 strings\n        Date.parse = function parse(string) {\n            var match = isoDateExpression.exec(string);\n            if (match) {\n                match.shift(); // kill match[0], the full match\n                // parse months, days, hours, minutes, seconds, and milliseconds\n                for (var i = 1; i < 7; i++) {\n                    // provide default values if necessary\n                    match[i] = +(match[i] || (i < 3 ? 1 : 0));\n                    // match[1] is the month. Months are 0-11 in JavaScript\n                    // `Date` objects, but 1-12 in ISO notation, so we\n                    // decrement.\n                    if (i == 1) {\n                        match[i]--;\n                    }\n                }\n\n                // parse the UTC offset component\n                var minuteOffset = +match.pop(), hourOffset = +match.pop(), sign = match.pop();\n\n                // compute the explicit time zone offset if specified\n                var offset = 0;\n                if (sign) {\n                    // detect invalid offsets and return early\n                    if (hourOffset > 23 || minuteOffset > 59) {\n                        return NaN;\n                    }\n\n                    // express the provided time zone offset in minutes. The offset is\n                    // negative for time zones west of UTC; positive otherwise.\n                    offset = (hourOffset * 60 + minuteOffset) * 6e4 * (sign == \"+\" ? -1 : 1);\n                }\n\n                // Date.UTC for years between 0 and 99 converts year to 1900 + year\n                // The Gregorian calendar has a 400-year cycle, so\n                // to Date.UTC(year + 400, .... ) - 12622780800000 == Date.UTC(year, ...),\n                // where 12622780800000 - number of milliseconds in Gregorian calendar 400 years\n                var year = +match[0];\n                if (0 <= year && year <= 99) {\n                    match[0] = year + 400;\n                    return NativeDate.UTC.apply(this, match) + offset - 12622780800000;\n                }\n\n                // compute a new UTC date value, accounting for the optional offset\n                return NativeDate.UTC.apply(this, match) + offset;\n            }\n            return NativeDate.parse.apply(this, arguments);\n        };\n\n        return Date;\n    })(Date);\n}\n\n//\n// String\n// ======\n//\n\n// ES5 15.5.4.20\n// http://es5.github.com/#x15.5.4.20\nvar ws = \"\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\" +\n    \"\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\" +\n    \"\\u2029\\uFEFF\";\nif (!String.prototype.trim || ws.trim()) {\n    // http://blog.stevenlevithan.com/archives/faster-trim-javascript\n    // http://perfectionkills.com/whitespace-deviations/\n    ws = \"[\" + ws + \"]\";\n    var trimBeginRegexp = new RegExp(\"^\" + ws + ws + \"*\"),\n        trimEndRegexp = new RegExp(ws + ws + \"*$\");\n    String.prototype.trim = function trim() {\n        if (this === undefined || this === null) {\n            throw new TypeError(\"can't convert \"+this+\" to object\");\n        }\n        return String(this).replace(trimBeginRegexp, \"\").replace(trimEndRegexp, \"\");\n    };\n}\n\n//\n// Util\n// ======\n//\n\n// ES5 9.4\n// http://es5.github.com/#x9.4\n// http://jsperf.com/to-integer\nvar toInteger = function (n) {\n    n = +n;\n    if (n !== n) { // isNaN\n        n = 0;\n    } else if (n !== 0 && n !== (1/0) && n !== -(1/0)) {\n        n = (n > 0 || -1) * Math.floor(Math.abs(n));\n    }\n    return n;\n};\n\nvar prepareString = \"a\"[0] != \"a\";\n    // ES5 9.9\n    // http://es5.github.com/#x9.9\nvar toObject = function (o) {\n    if (o == null) { // this matches both null and undefined\n        throw new TypeError(\"can't convert \"+o+\" to object\");\n    }\n    // If the implementation doesn't support by-index access of\n    // string characters (ex. IE < 9), split the string\n    if (prepareString && typeof o == \"string\" && o) {\n        return o.split(\"\");\n    }\n    return Object(o);\n};\n\n});\n\n// Copyright 2009-2012 by contributors, MIT License\n// vim: ts=4 sts=4 sw=4 expandtab\n\n// Module systems magic dance\n(function (definition) {\n    // RequireJS\n    if (typeof define == \"function\") {\n        define('sham',definition);\n    // YUI3\n    } else if (typeof YUI == \"function\") {\n        YUI.add(\"es5-sham\", definition);\n    // CommonJS and <script>\n    } else {\n        definition();\n    }\n})(function () {\n\n// ES5 15.2.3.2\n// http://es5.github.com/#x15.2.3.2\nif (!Object.getPrototypeOf) {\n    // https://github.com/kriskowal/es5-shim/issues#issue/2\n    // http://ejohn.org/blog/objectgetprototypeof/\n    // recommended by fschaefer on github\n    Object.getPrototypeOf = function getPrototypeOf(object) {\n        return object.__proto__ || (\n            object.constructor\n                ? object.constructor.prototype\n                : prototypeOfObject\n        );\n    };\n}\n\n// ES5 15.2.3.3\n// http://es5.github.com/#x15.2.3.3\nif (!Object.getOwnPropertyDescriptor) {\n    var ERR_NON_OBJECT = \"Object.getOwnPropertyDescriptor called on a non-object: \";\n\n    Object.getOwnPropertyDescriptor = function getOwnPropertyDescriptor(object, property) {\n        if ((typeof object != \"object\" && typeof object != \"function\") || object === null) {\n            throw new TypeError(ERR_NON_OBJECT + object);\n        }\n        // If object does not owns property return undefined immediately.\n        if (!owns(object, property)) {\n            return;\n        }\n\n        // If object has a property then it's for sure both `enumerable` and\n        // `configurable`.\n        var descriptor =  { enumerable: true, configurable: true };\n\n        // If JS engine supports accessor properties then property may be a\n        // getter or setter.\n        if (supportsAccessors) {\n            // Unfortunately `__lookupGetter__` will return a getter even\n            // if object has own non getter property along with a same named\n            // inherited getter. To avoid misbehavior we temporary remove\n            // `__proto__` so that `__lookupGetter__` will return getter only\n            // if it's owned by an object.\n            var prototype = object.__proto__;\n            object.__proto__ = prototypeOfObject;\n\n            var getter = lookupGetter(object, property);\n            var setter = lookupSetter(object, property);\n\n            // Once we have getter and setter we can put values back.\n            object.__proto__ = prototype;\n\n            if (getter || setter) {\n                if (getter) {\n                    descriptor.get = getter;\n                }\n                if (setter) {\n                    descriptor.set = setter;\n                }\n                // If it was accessor property we're done and return here\n                // in order to avoid adding `value` to the descriptor.\n                return descriptor;\n            }\n        }\n\n        // If we got this far we know that object has an own property that is\n        // not an accessor so we set it as a value and return descriptor.\n        descriptor.value = object[property];\n        return descriptor;\n    };\n}\n\n// ES5 15.2.3.4\n// http://es5.github.com/#x15.2.3.4\nif (!Object.getOwnPropertyNames) {\n    Object.getOwnPropertyNames = function getOwnPropertyNames(object) {\n        return Object.keys(object);\n    };\n}\n\n// ES5 15.2.3.5\n// http://es5.github.com/#x15.2.3.5\nif (!Object.create) {\n    Object.create = function create(prototype, properties) {\n        var object;\n        if (prototype === null) {\n            object = { \"__proto__\": null };\n        } else {\n            if (typeof prototype != \"object\") {\n                throw new TypeError(\"typeof prototype[\"+(typeof prototype)+\"] != 'object'\");\n            }\n            var Type = function () {};\n            Type.prototype = prototype;\n            object = new Type();\n            // IE has no built-in implementation of `Object.getPrototypeOf`\n            // neither `__proto__`, but this manually setting `__proto__` will\n            // guarantee that `Object.getPrototypeOf` will work as expected with\n            // objects created using `Object.create`\n            object.__proto__ = prototype;\n        }\n        if (properties !== void 0) {\n            Object.defineProperties(object, properties);\n        }\n        return object;\n    };\n}\n\n// ES5 15.2.3.6\n// http://es5.github.com/#x15.2.3.6\n\n// Patch for WebKit and IE8 standard mode\n// Designed by hax <hax.github.com>\n// related issue: https://github.com/kriskowal/es5-shim/issues#issue/5\n// IE8 Reference:\n//     http://msdn.microsoft.com/en-us/library/dd282900.aspx\n//     http://msdn.microsoft.com/en-us/library/dd229916.aspx\n// WebKit Bugs:\n//     https://bugs.webkit.org/show_bug.cgi?id=36423\n\nfunction doesDefinePropertyWork(object) {\n    try {\n        Object.defineProperty(object, \"sentinel\", {});\n        return \"sentinel\" in object;\n    } catch (exception) {\n        // returns falsy\n    }\n}\n\n// check whether defineProperty works if it's given. Otherwise,\n// shim partially.\nif (Object.defineProperty) {\n    var definePropertyWorksOnObject = doesDefinePropertyWork({});\n    var definePropertyWorksOnDom = typeof document == \"undefined\" ||\n        doesDefinePropertyWork(document.createElement(\"div\"));\n    if (!definePropertyWorksOnObject || !definePropertyWorksOnDom) {\n        var definePropertyFallback = Object.defineProperty;\n    }\n}\n\nif (!Object.defineProperty || definePropertyFallback) {\n    var ERR_NON_OBJECT_DESCRIPTOR = \"Property description must be an object: \";\n    var ERR_NON_OBJECT_TARGET = \"Object.defineProperty called on non-object: \"\n    var ERR_ACCESSORS_NOT_SUPPORTED = \"getters & setters can not be defined \" +\n                                      \"on this javascript engine\";\n\n    Object.defineProperty = function defineProperty(object, property, descriptor) {\n        if ((typeof object != \"object\" && typeof object != \"function\") || object === null) {\n            throw new TypeError(ERR_NON_OBJECT_TARGET + object);\n        }\n        if ((typeof descriptor != \"object\" && typeof descriptor != \"function\") || descriptor === null) {\n            throw new TypeError(ERR_NON_OBJECT_DESCRIPTOR + descriptor);\n        }\n        // make a valiant attempt to use the real defineProperty\n        // for I8's DOM elements.\n        if (definePropertyFallback) {\n            try {\n                return definePropertyFallback.call(Object, object, property, descriptor);\n            } catch (exception) {\n                // try the shim if the real one doesn't work\n            }\n        }\n\n        // If it's a data property.\n        if (owns(descriptor, \"value\")) {\n            // fail silently if \"writable\", \"enumerable\", or \"configurable\"\n            // are requested but not supported\n            /*\n            // alternate approach:\n            if ( // can't implement these features; allow false but not true\n                !(owns(descriptor, \"writable\") ? descriptor.writable : true) ||\n                !(owns(descriptor, \"enumerable\") ? descriptor.enumerable : true) ||\n                !(owns(descriptor, \"configurable\") ? descriptor.configurable : true)\n            )\n                throw new RangeError(\n                    \"This implementation of Object.defineProperty does not \" +\n                    \"support configurable, enumerable, or writable.\"\n                );\n            */\n\n            if (supportsAccessors && (lookupGetter(object, property) ||\n                                      lookupSetter(object, property)))\n            {\n                // As accessors are supported only on engines implementing\n                // `__proto__` we can safely override `__proto__` while defining\n                // a property to make sure that we don't hit an inherited\n                // accessor.\n                var prototype = object.__proto__;\n                object.__proto__ = prototypeOfObject;\n                // Deleting a property anyway since getter / setter may be\n                // defined on object itself.\n                delete object[property];\n                object[property] = descriptor.value;\n                // Setting original `__proto__` back now.\n                object.__proto__ = prototype;\n            } else {\n                object[property] = descriptor.value;\n            }\n        } else {\n            if (!supportsAccessors) {\n                throw new TypeError(ERR_ACCESSORS_NOT_SUPPORTED);\n            }\n            // If we got that far then getters and setters can be defined !!\n            if (owns(descriptor, \"get\")) {\n                defineGetter(object, property, descriptor.get);\n            }\n            if (owns(descriptor, \"set\")) {\n                defineSetter(object, property, descriptor.set);\n            }\n        }\n        return object;\n    };\n}\n\n// ES5 15.2.3.7\n// http://es5.github.com/#x15.2.3.7\nif (!Object.defineProperties) {\n    Object.defineProperties = function defineProperties(object, properties) {\n        for (var property in properties) {\n            if (owns(properties, property) && property != \"__proto__\") {\n                Object.defineProperty(object, property, properties[property]);\n            }\n        }\n        return object;\n    };\n}\n\n// ES5 15.2.3.8\n// http://es5.github.com/#x15.2.3.8\nif (!Object.seal) {\n    Object.seal = function seal(object) {\n        // this is misleading and breaks feature-detection, but\n        // allows \"securable\" code to \"gracefully\" degrade to working\n        // but insecure code.\n        return object;\n    };\n}\n\n// ES5 15.2.3.9\n// http://es5.github.com/#x15.2.3.9\nif (!Object.freeze) {\n    Object.freeze = function freeze(object) {\n        // this is misleading and breaks feature-detection, but\n        // allows \"securable\" code to \"gracefully\" degrade to working\n        // but insecure code.\n        return object;\n    };\n}\n\n// detect a Rhino bug and patch it\ntry {\n    Object.freeze(function () {});\n} catch (exception) {\n    Object.freeze = (function freeze(freezeObject) {\n        return function freeze(object) {\n            if (typeof object == \"function\") {\n                return object;\n            } else {\n                return freezeObject(object);\n            }\n        };\n    })(Object.freeze);\n}\n\n// ES5 15.2.3.10\n// http://es5.github.com/#x15.2.3.10\nif (!Object.preventExtensions) {\n    Object.preventExtensions = function preventExtensions(object) {\n        // this is misleading and breaks feature-detection, but\n        // allows \"securable\" code to \"gracefully\" degrade to working\n        // but insecure code.\n        return object;\n    };\n}\n\n// ES5 15.2.3.11\n// http://es5.github.com/#x15.2.3.11\nif (!Object.isSealed) {\n    Object.isSealed = function isSealed(object) {\n        return false;\n    };\n}\n\n// ES5 15.2.3.12\n// http://es5.github.com/#x15.2.3.12\nif (!Object.isFrozen) {\n    Object.isFrozen = function isFrozen(object) {\n        return false;\n    };\n}\n\n// ES5 15.2.3.13\n// http://es5.github.com/#x15.2.3.13\nif (!Object.isExtensible) {\n    Object.isExtensible = function isExtensible(object) {\n        // 1. If Type(O) is not Object throw a TypeError exception.\n        if (Object(object) !== object) {\n            throw new TypeError(); // TODO message\n        }\n        // 2. Return the Boolean value of the [[Extensible]] internal property of O.\n        var name = '';\n        while (owns(object, name)) {\n            name += '?';\n        }\n        object[name] = true;\n        var returnValue = owns(object, name);\n        delete object[name];\n        return returnValue;\n    };\n}\n\n});\n\n// ==========================================\n// Copyright 2013 Twitter, Inc\n// Licensed under The MIT License\n// http://opensource.org/licenses/MIT\n// ==========================================\n\n\n\ndefine('assets/js/components/flight/lib/utils',\n\n  [],\n\n  function () {\n\n    var arry = [];\n    var DEFAULT_INTERVAL = 100;\n\n    var utils = {\n\n      isDomObj: function(obj) {\n        return !!(obj.nodeType || (obj === window));\n      },\n\n      toArray: function(obj, from) {\n        return arry.slice.call(obj, from);\n      },\n\n      // returns new object representing multiple objects merged together\n      // optional final argument is boolean which specifies if merge is recursive\n      // original objects are unmodified\n      //\n      // usage:\n      //   var base = {a:2, b:6};\n      //   var extra = {b:3, c:4};\n      //   merge(base, extra); //{a:2, b:3, c:4}\n      //   base; //{a:2, b:6}\n      //\n      //   var base = {a:2, b:6};\n      //   var extra = {b:3, c:4};\n      //   var extraExtra = {a:4, d:9};\n      //   merge(base, extra, extraExtra); //{a:4, b:3, c:4. d: 9}\n      //   base; //{a:2, b:6}\n      //\n      //   var base = {a:2, b:{bb:4, cc:5}};\n      //   var extra = {a:4, b:{cc:7, dd:1}};\n      //   merge(base, extra, true); //{a:4, b:{bb:4, cc:7, dd:1}}\n      //   base; //{a:2, b:6}\n\n      merge: function(/*obj1, obj2,....deepCopy*/) {\n        var args = this.toArray(arguments);\n\n        //start with empty object so a copy is created\n        args.unshift({});\n\n        if (args[args.length - 1] === true) {\n          //jquery extend requires deep copy as first arg\n          args.pop();\n          args.unshift(true);\n        }\n\n        return $.extend.apply(undefined, args);\n      },\n\n      // updates base in place by copying properties of extra to it\n      // optionally clobber protected\n      // usage:\n      //   var base = {a:2, b:6};\n      //   var extra = {c:4};\n      //   push(base, extra); //{a:2, b:6, c:4}\n      //   base; //{a:2, b:6, c:4}\n      //\n      //   var base = {a:2, b:6};\n      //   var extra = {b: 4 c:4};\n      //   push(base, extra, true); //Error (\"utils.push attempted to overwrite 'b' while running in protected mode\")\n      //   base; //{a:2, b:6}\n      //\n      // objects with the same key will merge recursively when protect is false\n      // eg:\n      // var base = {a:16, b:{bb:4, cc:10}};\n      // var extra = {b:{cc:25, dd:19}, c:5};\n      // push(base, extra); //{a:16, {bb:4, cc:25, dd:19}, c:5}\n      //\n      push: function(base, extra, protect) {\n        if (base) {\n          Object.keys(extra || {}).forEach(function(key) {\n            if (base[key] && protect) {\n              throw Error(\"utils.push attempted to overwrite '\" + key + \"' while running in protected mode\");\n            }\n\n            if (typeof base[key] == \"object\" && typeof extra[key] == \"object\") {\n              //recurse\n              this.push(base[key], extra[key]);\n            } else {\n              //no protect, so extra wins\n              base[key] = extra[key];\n            }\n          }, this);\n        }\n\n        return base;\n      },\n\n      isEnumerable: function(obj, property) {\n        return Object.keys(obj).indexOf(property) > -1;\n      },\n\n      //build a function from other function(s)\n      //util.compose(a,b,c) -> a(b(c()));\n      //implementation lifted from underscore.js (c) 2009-2012 Jeremy Ashkenas\n      compose: function() {\n        var funcs = arguments;\n\n        return function() {\n          var args = arguments;\n\n          for (var i = funcs.length-1; i >= 0; i--) {\n            args = [funcs[i].apply(this, args)];\n          }\n\n          return args[0];\n        };\n      },\n\n      // Can only unique arrays of homogeneous primitives, e.g. an array of only strings, an array of only booleans, or an array of only numerics\n      uniqueArray: function(array) {\n        var u = {}, a = [];\n\n        for (var i = 0, l = array.length; i < l; ++i) {\n          if (u.hasOwnProperty(array[i])) {\n            continue;\n          }\n\n          a.push(array[i]);\n          u[array[i]] = 1;\n        }\n\n        return a;\n      },\n\n      debounce: function(func, wait, immediate) {\n        if (typeof wait != 'number') {\n          wait = DEFAULT_INTERVAL;\n        }\n\n        var timeout, result;\n\n        return function() {\n          var context = this, args = arguments;\n          var later = function() {\n            timeout = null;\n            if (!immediate) {\n              result = func.apply(context, args);\n            }\n          };\n          var callNow = immediate && !timeout;\n\n          clearTimeout(timeout);\n          timeout = setTimeout(later, wait);\n\n          if (callNow) {\n            result = func.apply(context, args);\n          }\n\n          return result;\n        };\n      },\n\n      throttle: function(func, wait) {\n        if (typeof wait != 'number') {\n          wait = DEFAULT_INTERVAL;\n        }\n\n        var context, args, timeout, throttling, more, result;\n        var whenDone = this.debounce(function(){\n          more = throttling = false;\n        }, wait);\n\n        return function() {\n          context = this; args = arguments;\n          var later = function() {\n            timeout = null;\n            if (more) {\n              result = func.apply(context, args);\n            }\n            whenDone();\n          };\n\n          if (!timeout) {\n            timeout = setTimeout(later, wait);\n          }\n\n          if (throttling) {\n            more = true;\n          } else {\n            throttling = true;\n            result = func.apply(context, args);\n          }\n\n          whenDone();\n          return result;\n        };\n      },\n\n      countThen: function(num, base) {\n        return function() {\n          if (!--num) { return base.apply(this, arguments); }\n        };\n      },\n\n      delegate: function(rules) {\n        return function(e, data) {\n          var target = $(e.target), parent;\n\n          Object.keys(rules).forEach(function(selector) {\n            if ((parent = target.closest(selector)).length) {\n              data = data || {};\n              data.el = parent[0];\n              return rules[selector].apply(this, [e, data]);\n            }\n          }, this);\n        };\n      }\n\n    };\n\n    return utils;\n  }\n);\n\n// ==========================================\n// Copyright 2013 Twitter, Inc\n// Licensed under The MIT License\n// http://opensource.org/licenses/MIT\n// ==========================================\n\n\n\ndefine('assets/js/components/flight/lib/registry',\n\n  [\n    './utils'\n  ],\n\n  function (util) {\n\n    function parseEventArgs(instance, args) {\n      var element, type, callback;\n\n      args = util.toArray(args);\n\n      if (typeof args[args.length-1] === 'function') {\n        callback = args.pop();\n      }\n\n      if (typeof args[args.length-1] === 'object') {\n        args.pop();\n      }\n\n      if (args.length == 2) {\n        element = args[0];\n        type = args[1];\n      } else {\n        element = instance.node;\n        type = args[0];\n      }\n\n      return {\n        element: element,\n        type: type,\n        callback: callback\n      };\n    }\n\n    function matchEvent(a, b) {\n      return (\n        (a.element == b.element) &&\n        (a.type == b.type) &&\n        (b.callback == null || (a.callback == b.callback))\n      );\n    }\n\n    function Registry() {\n\n      var registry = this;\n\n      (this.reset = function() {\n        this.components = [];\n        this.allInstances = [];\n        this.events = [];\n      }).call(this);\n\n      function ComponentInfo(component) {\n        this.component = component;\n        this.instances = [];\n\n        this.addInstance = function(instance) {\n          this.throwIfInstanceExistsOnNode(instance);\n\n          var instanceInfo = new InstanceInfo(instance);\n          this.instances.push(instanceInfo);\n\n          return instanceInfo;\n        }\n\n        this.throwIfInstanceExistsOnNode = function(instance) {\n          this.instances.forEach(function (instanceInfo) {\n            if (instanceInfo.instance.$node[0] === instance.$node[0]) {\n              throw new Error('Instance of ' + instance.constructor + ' already exists on node ' + instance.$node[0]);\n            }\n          });\n        }\n\n        this.removeInstance = function(instance) {\n          var instanceInfo = this.instances.filter(function(instanceInfo) {\n            return instanceInfo.instance == instance;\n          })[0];\n\n          var index = this.instances.indexOf(instanceInfo);\n\n          (index > -1)  && this.instances.splice(index, 1);\n\n          if (!this.instances.length) {\n            //if I hold no more instances remove me from registry\n            registry.removeComponentInfo(this);\n          }\n        }\n      }\n\n      function InstanceInfo(instance) {\n        this.instance = instance;\n        this.events = [];\n\n        this.addTrigger = function() {};\n\n        this.addBind = function(event) {\n          this.events.push(event);\n          registry.events.push(event);\n        };\n\n        this.removeBind = function(event) {\n          for (var i = 0, e; e = this.events[i]; i++) {\n            if (matchEvent(e, event)) {\n              this.events.splice(i, 1);\n            }\n          }\n        }\n      }\n\n      this.addInstance = function(instance) {\n        var component = this.findComponentInfo(instance);\n\n        if (!component) {\n          component = new ComponentInfo(instance.constructor);\n          this.components.push(component);\n        }\n\n        var inst = component.addInstance(instance);\n\n        this.allInstances.push(inst);\n\n        return component;\n      };\n\n      this.removeInstance = function(instance) {\n        var index, instInfo = this.findInstanceInfo(instance);\n\n        //remove from component info\n        var componentInfo = this.findComponentInfo(instance);\n        componentInfo.removeInstance(instance);\n\n        //remove from registry\n        var index = this.allInstances.indexOf(instInfo);\n        (index > -1)  && this.allInstances.splice(index, 1);\n      };\n\n      this.removeComponentInfo = function(componentInfo) {\n        var index = this.components.indexOf(componentInfo);\n        (index > -1)  && this.components.splice(index, 1);\n      };\n\n      this.findComponentInfo = function(which) {\n        var component = which.attachTo ? which : which.constructor;\n\n        for (var i = 0, c; c = this.components[i]; i++) {\n          if (c.component === component) {\n            return c;\n          }\n        }\n\n        return null;\n      };\n\n      this.findInstanceInfo = function(which) {\n        var testFn;\n\n        if (which.node) {\n          //by instance (returns matched instance)\n          testFn = function(inst) {return inst.instance === which};\n        } else {\n          //by node (returns array of matches)\n          testFn = function(inst) {return inst.instance.node === which};\n        }\n\n        var matches = this.allInstances.filter(testFn);\n        if (!matches.length) {\n          return which.node ? null : [];\n        }\n        return which.node ? matches[0] : matches;\n      };\n\n      this.trigger = function() {\n        var event = parseEventArgs(this, arguments),\n            instance = registry.findInstanceInfo(this);\n\n        if (instance) {\n          instance.addTrigger(event);\n        }\n      };\n\n      this.on = function(componentOn) {\n        var otherArgs = util.toArray(arguments, 1);\n        var instance = registry.findInstanceInfo(this);\n        var boundCallback;\n\n        if (instance) {\n          boundCallback = componentOn.apply(null, otherArgs);\n          if(boundCallback) {\n            otherArgs[otherArgs.length-1] = boundCallback;\n          }\n          var event = parseEventArgs(this, otherArgs);\n          instance.addBind(event);\n        }\n      };\n\n      this.off = function(el, type, callback) {\n        var event = parseEventArgs(this, arguments),\n            instance = registry.findInstanceInfo(this);\n\n        if (instance) {\n          instance.removeBind(event);\n        }\n      };\n\n      this.teardown = function() {\n        registry.removeInstance(this);\n      };\n\n      this.withRegistration = function() {\n        this.before('initialize', function() {\n          registry.addInstance(this);\n        });\n\n        this.after('trigger', registry.trigger);\n        this.around('on', registry.on);\n        this.after('off', registry.off);\n        this.after('teardown', {obj:registry, fnName:'teardown'});\n      };\n\n    }\n\n    return new Registry;\n  }\n);\n\n\n\ndefine('assets/js/components/flight/tools/debug/debug',\n\n  [\n    '../../lib/registry',\n    '../../lib/utils'\n  ],\n\n  function(registry, utils) {\n\n    var logFilter;\n\n    //******************************************************************************************\n    // Search object model\n    //******************************************************************************************\n\n    function traverse(util, searchTerm, options) {\n      var options = options || {};\n      var obj = options.obj || window;\n      var path = options.path || ((obj==window) ? \"window\" : \"\");\n      var props = Object.keys(obj);\n      props.forEach(function(prop) {\n        if ((tests[util] || util)(searchTerm, obj, prop)){\n          console.log([path, \".\", prop].join(\"\"), \"->\",[\"(\", typeof obj[prop], \")\"].join(\"\"), obj[prop]);\n        }\n        if(Object.prototype.toString.call(obj[prop])==\"[object Object]\" && (obj[prop] != obj) && path.split(\".\").indexOf(prop) == -1) {\n          traverse(util, searchTerm, {obj: obj[prop], path: [path,prop].join(\".\")});\n        }\n      });\n    }\n\n    function search(util, expected, searchTerm, options) {\n      if (!expected || typeof searchTerm == expected) {\n        traverse(util, searchTerm, options);\n      } else {\n        console.error([searchTerm, 'must be', expected].join(' '))\n      }\n    }\n\n    var tests = {\n      'name': function(searchTerm, obj, prop) {return searchTerm == prop},\n      'nameContains': function(searchTerm, obj, prop) {return prop.indexOf(searchTerm)>-1},\n      'type': function(searchTerm, obj, prop) {return obj[prop] instanceof searchTerm},\n      'value': function(searchTerm, obj, prop) {return obj[prop] === searchTerm},\n      'valueCoerced': function(searchTerm, obj, prop) {return obj[prop] == searchTerm}\n    }\n\n    function byName(searchTerm, options) {search('name', 'string', searchTerm, options);};\n    function byNameContains(searchTerm, options) {search('nameContains', 'string', searchTerm, options);};\n    function byType(searchTerm, options) {search('type', 'function', searchTerm, options);};\n    function byValue(searchTerm, options) {search('value', null, searchTerm, options);};\n    function byValueCoerced(searchTerm, options) {search('valueCoerced', null, searchTerm, options);};\n    function custom(fn, options) {traverse(fn, null, options);};\n\n    //******************************************************************************************\n    // Event logging\n    //******************************************************************************************\n    var logLevel = 'all';\n    logFilter = {actions: logLevel, eventNames: logLevel}; //no filter by default\n\n    function filterEventLogsByAction(/*actions*/) {\n      var actions = [].slice.call(arguments, 0);\n\n      logFilter.eventNames.length || (logFilter.eventNames = 'all');\n      logFilter.actions = actions.length ? actions : 'all';\n    }\n\n    function filterEventLogsByName(/*eventNames*/) {\n      var eventNames = [].slice.call(arguments, 0);\n\n      logFilter.actions.length || (logFilter.actions = 'all');\n      logFilter.eventNames = eventNames.length ? eventNames : 'all';\n    }\n\n    function hideAllEventLogs() {\n      logFilter.actions = [];\n      logFilter.eventNames = [];\n    }\n\n    function showAllEventLogs() {\n      logFilter.actions = 'all';\n      logFilter.eventNames = 'all';\n    }\n\n    return {\n\n      enable: function(enable) {\n        this.enabled = !!enable;\n\n        if (enable && window.console) {\n          console.info('Booting in DEBUG mode');\n          console.info('You can filter event logging with DEBUG.events.logAll/logNone/logByName/logByAction');\n        }\n\n        window.DEBUG = this;\n      },\n\n      find: {\n        byName: byName,\n        byNameContains: byNameContains,\n        byType: byType,\n        byValue: byValue,\n        byValueCoerced: byValueCoerced,\n        custom: custom\n      },\n\n      events: {\n        logFilter: logFilter,\n\n        // Accepts any number of action args\n        // e.g. DEBUG.events.logByAction(\"on\", \"off\")\n        logByAction: filterEventLogsByAction,\n\n        // Accepts any number of event name args (inc. regex or wildcards)\n        // e.g. DEBUG.events.logByName(/ui.*/, \"*Thread*\");\n        logByName: filterEventLogsByName,\n\n        logAll: showAllEventLogs,\n        logNone: hideAllEventLogs\n      }\n    };\n  }\n);\n\n\n// ==========================================\n// Copyright 2013 Twitter, Inc\n// Licensed under The MIT License\n// http://opensource.org/licenses/MIT\n// ==========================================\n\n\n\ndefine('assets/js/components/flight/lib/compose',\n\n  [\n    './utils',\n    '../tools/debug/debug'\n  ],\n\n  function(util, debug) {\n\n    //enumerables are shims - getOwnPropertyDescriptor shim doesn't work\n    var canWriteProtect = debug.enabled && !util.isEnumerable(Object, 'getOwnPropertyDescriptor');\n    //whitelist of unlockable property names\n    var dontLock = ['mixedIn'];\n\n    if (canWriteProtect) {\n      //IE8 getOwnPropertyDescriptor is built-in but throws exeption on non DOM objects\n      try {\n        Object.getOwnPropertyDescriptor(Object, 'keys');\n      } catch(e) {\n        canWriteProtect = false;\n      }\n    }\n\n    function setPropertyWritability(obj, isWritable) {\n      if (!canWriteProtect) {\n        return;\n      }\n\n      var props = Object.create(null);\n\n      Object.keys(obj).forEach(\n        function (key) {\n          if (dontLock.indexOf(key) < 0) {\n            var desc = Object.getOwnPropertyDescriptor(obj, key);\n            desc.writable = isWritable;\n            props[key] = desc;\n          }\n        }\n      );\n\n      Object.defineProperties(obj, props);\n    }\n\n    function unlockProperty(obj, prop, op) {\n      var writable;\n\n      if (!canWriteProtect || !obj.hasOwnProperty(prop)) {\n        op.call(obj);\n        return;\n      }\n\n      writable = Object.getOwnPropertyDescriptor(obj, prop).writable;\n      Object.defineProperty(obj, prop, { writable: true });\n      op.call(obj);\n      Object.defineProperty(obj, prop, { writable: writable });\n    }\n\n    function mixin(base, mixins) {\n      base.mixedIn = base.hasOwnProperty('mixedIn') ? base.mixedIn : [];\n\n      mixins.forEach(function(mixin) {\n        if (base.mixedIn.indexOf(mixin) == -1) {\n          setPropertyWritability(base, false);\n          mixin.call(base);\n          base.mixedIn.push(mixin);\n        }\n      });\n\n      setPropertyWritability(base, true);\n    }\n\n    return {\n      mixin: mixin,\n      unlockProperty: unlockProperty\n    };\n\n  }\n);\n\n// ==========================================\n// Copyright 2013 Twitter, Inc\n// Licensed under The MIT License\n// http://opensource.org/licenses/MIT\n// ==========================================\n\n\n\ndefine('assets/js/components/flight/lib/advice',\n\n  [\n    './utils',\n    './compose'\n  ],\n\n  function (util, compose) {\n\n    var advice = {\n\n      around: function(base, wrapped) {\n        return function() {\n          var args = util.toArray(arguments);\n          return wrapped.apply(this, [base.bind(this)].concat(args));\n        }\n      },\n\n      before: function(base, before) {\n        return this.around(base, function() {\n          var args = util.toArray(arguments),\n              orig = args.shift(),\n              beforeFn;\n\n          beforeFn = (typeof before == 'function') ? before : before.obj[before.fnName];\n          beforeFn.apply(this, args);\n          return (orig).apply(this, args);\n        });\n      },\n\n      after: function(base, after) {\n        return this.around(base, function() {\n          var args = util.toArray(arguments),\n              orig = args.shift(),\n              afterFn;\n\n          // this is a separate statement for debugging purposes.\n          var res = (orig.unbound || orig).apply(this, args);\n\n          afterFn = (typeof after == 'function') ? after : after.obj[after.fnName];\n          afterFn.apply(this, args);\n          return res;\n        });\n      },\n\n      // a mixin that allows other mixins to augment existing functions by adding additional\n      // code before, after or around.\n      withAdvice: function() {\n        ['before', 'after', 'around'].forEach(function(m) {\n          this[m] = function(method, fn) {\n\n            compose.unlockProperty(this, method, function() {\n              if (typeof this[method] == 'function') {\n                return this[method] = advice[m](this[method], fn);\n              } else {\n                return this[method] = fn;\n              }\n            });\n\n          };\n        }, this);\n      }\n    };\n\n    return advice;\n  }\n);\n\n// ==========================================\n// Copyright 2013 Twitter, Inc\n// Licensed under The MIT License\n// http://opensource.org/licenses/MIT\n// ==========================================\n\n\n\ndefine('assets/js/components/flight/lib/logger',\n\n  [\n    './compose',\n    './utils'\n  ],\n\n  function (compose, util) {\n\n    var actionSymbols = {\n      on:'<-',\n      trigger: '->',\n      off: 'x '\n    };\n\n    function elemToString(elem) {\n      var tagStr = elem.tagName ? elem.tagName.toLowerCase() : elem.toString();\n      var classStr = elem.className ? \".\" + (elem.className) : \"\";\n      var result = tagStr + classStr;\n      return elem.tagName ? ['\\'', '\\''].join(result) : result;\n    }\n\n    function log(action, component, eventArgs) {\n\n      var name, elem, fn, fnName, logFilter, toRegExp, actionLoggable, nameLoggable;\n\n      if (typeof eventArgs[eventArgs.length-1] == 'function') {\n        fn = eventArgs.pop();\n        fn = fn.unbound || fn; //use unbound version if any (better info)\n      }\n\n      if (typeof eventArgs[eventArgs.length - 1] == 'object') {\n        eventArgs.pop(); //trigger data arg - not logged right now\n      }\n\n      if (eventArgs.length == 2) {\n        elem = eventArgs[0];\n        name = eventArgs[1];\n      } else {\n        elem = component.$node[0];\n        name = eventArgs[0];\n      }\n\n      if (window.DEBUG) {\n        logFilter = DEBUG.events.logFilter;\n\n        // no regex for you, actions...\n        actionLoggable = logFilter.actions==\"all\" || (logFilter.actions.indexOf(action) > -1);\n        // event name filter allow wildcards or regex...\n        toRegExp = function(expr) {\n          return expr.test ? expr : new RegExp(\"^\" + expr.replace(/\\*/g, \".*\") + \"$\");\n        };\n        nameLoggable =\n          logFilter.eventNames==\"all\" ||\n          logFilter.eventNames.some(function(e) {return toRegExp(e).test(name)});\n\n        if (actionLoggable && nameLoggable) {\n          console.info(\n            actionSymbols[action],\n            action,\n            '[' + name + ']',\n            elemToString(elem),\n            component.constructor.describe,\n            fn && (fnName = fn.name || fn.displayName) && '->  ' + fnName\n          );\n        }\n      }\n    }\n\n\n    function withLogging() {\n      this.before('trigger', function() {\n        log('trigger', this, util.toArray(arguments));\n      });\n      this.before('on', function() {\n        log('on', this, util.toArray(arguments));\n      });\n      this.before('off', function(eventArgs) {\n        log('off', this, util.toArray(arguments));\n      });\n    }\n\n    return withLogging;\n  }\n);\n\nrequire.config({\n  paths: {\n    jquery: 'assets/js/components/jquery/jquery.min',\n    underscore: 'assets/js/components/underscore/underscore-min',\n    director: 'assets/js/components/director/build/director_AMD',\n    shim:'assets/js/components/es5-shim/es5-shim.min',\n    sham:'assets/js/components/es5-shim/es5-sham.min',\n    router:'src/router',\n    mustache:'assets/js/components/mustache/mustache'  \n  }\n});\nrequire(\n        [\n          'shim',\n          'sham',\n          'assets/js/components/flight/lib/compose',\n          'assets/js/components/flight/lib/registry',\n          'assets/js/components/flight/lib/advice',\n          'assets/js/components/flight/lib/logger',\n          \n        ],\n\n        function(shim,sham,compose, registry, advice, withLogging) {\n          compose.mixin(registry, [advice.withAdvice, withLogging]);\n          //App.initialize();\n        }\n      );\ndefine(\"entryPoint\", function(){});\n"]],"start1":0,"start2":0,"length1":0,"length2":64165}]],"length":64165}
